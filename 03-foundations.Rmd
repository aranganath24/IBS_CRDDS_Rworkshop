# (PART) Foundations {-}

# R as a Calculator

At its most basic, R can be used as a calculator. For instance: 

```{r}
# calculates 2+2
2+2
```

```{r}
# calculates 65 to the power of 4
65^4
```

While this is a useful starting point, the possibility of assigning values to objects (or variables) considerably increases the scope of the operations we are able to carry out. We turn to object assignment in the next sub-section. 

# Object assignment and manipulation

The concept of object (or variable) assignment is a fundamental concept when working in a scripting environment; indeed, the ability to easily assign values to objects is what allows us to easily and intuitively manipulate and process our data in a programmatic setting. To better understand the mechanics of object assignment, consider the following:

```{r}
# assign value 5 to new object named x
x<-5
```

In the code above, we use R's assignment operator, ```<-```, to assign the value 5 to an object named ```x```. Now that an object named ```x``` has been created and assigned the value 5, printing ```x``` in our console (or printing ```x``` in our script and running it) will return the value that has been assigned to the ```x``` object, i.e. 5: 

```{r}
# prints value assigned to "x"
x
```

More generally, the process of assignment effectively equates the output created by the code on the right side of the assignment operator (```<-```) to an object with a name that is specified on the left side of the assignment operator. Whenever we want to look at the contents of an object (i.e. the output created by the code to the right side of the assignment operator), we simply print the name of the object in the R console (or print the name and run it within a script). 

Let's create another object, named ```y```, and assign it the value "12": 

```{r}
# assign value 12 to new object named y
y<-12
```

As we noted above, we can print the value that was assigned to ```y``` by printing its name:

```{r}
# prints value assigned to "y"
y
```

It's possible to use existing objects to assign values to new ones. For example, we can assign the sum of ```x``` and ```y``` to a new object that we'll name ```xy_sum```: 

```{r}
# creates a new object, named "xy_sum" whose value is the sum of "x" and "y"
xy_sum<-x+y
```

Now, let's print the contents of ```xy_sum```

```{r}
# prints contents of "xy_sum"
xy_sum
```

As expected, we see that the value assigned to ```xy_sum``` is "17" (i.e. the sum of the values assigned to ```x``` and ```y```). 

It is possible to change the value assigned to a given object. For example, let's say we want to change the value assigned to ```x``` from "5" to "8":

```{r}
# assign value of "8" to object named "x"
x<-8
```

We can now confirm that ```x``` is now associated with the value "8"

```{r}
# prints updated value of "x"
x
```

It's worth noting that updating the value assigned to ```x``` will not automatically update the value assigned to ```xy_sum``` (which, recall, is the sum of ```x``` and ```y```). If we print the value assigned to ```xy_sum```, note that it is still "17"): 

```{r}
xy_sum
```

In order for the value assigned to ```xy_sum``` to be updated with the new value of ```x```, we must run the assignment operation again:

```{r}
# assigns sum of "y" and newly updated value of "x" to "xy_sum" object
xy_sum<-x+y
```

Now, the value of ```xy_sum``` should reflect the updated value of ```x```, which we can confirm by printing the value of ```xy_sum```:

```{r}
# prints value of "xy_sum"
xy_sum
```

Note that the value assigned to ```xy_sum``` is now "20" (the sum of "8" and "12"), rather than "17" (the sum of "5" and "12").

While the examples above were very simple, we can assign virtually any R code, and by extension, the data structure(s) generated by that code (such as datasets, vectors, graphs/plots etc.) to an R object. When naming your objects, try to be descriptive, so that the name of the object signifies something about its corresponding value. 

Below, consider a simple example of an object, named ```our_location``` that has been assigned a non-numeric value. It's value is a string, or textual information:

```{r}
# assigns text string "Boulder, CO" to 
our_location<-"Boulder, CO"
```

We can print string that has been assigned to the ```location``` object by typing the name of the object in our console, or running it from our script:

```{r}
# prints value of "our_location" object
our_location
```

Note that generally speaking, you have a lot of flexibility in naming your R objects, but there are certain rules. For example, object names must start with a letter, and cannot contain any special symbols (they can only contain letters, numbers, underscores, and periods). Also, object names cannot contain multiple unconnected words; if you'd like to use multiple words or phrases, connect the discrete elements with an underscore (```_```), or use camel case (where different words are distinguished by beginning each discrete word begins with a capitalized letter). 

It is also worth emphasizing that object names are case sensitive; in order to print the value assigned to an object, that object's name must be printed *exactly* as it was created. For example, if we were to type ```our_Location```, we would get an error, since there is no ```our_Location``` object (only an ```our_location``` object):

```{r, error=TRUE}
our_Location
```

In order to keep track of the objects we have created, we can use the handy ```ls()``` function, which will print the names of all the objects that are in memory:

```{r}
# prints objects in memory
ls()
```

# Data Structures

We now turn to a brief overview of some important data structures that help us to work with data in R. We will consider three data structures that are particularly useful: vectors, data frames, and lists. Note that this is not an exhaustive treatment of data structures in R; there are other structures, such as matrices and arrays, that are also important. However, we will limit our discussion to the data structures that are essential for getting started with data-based social scientific research in R. 

## Vectors

In R, a vector is a sequence of values. A vector is created using the ```c()``` function. For example, let's make a vector with some arbitrary numeric values:

In R, a vector is a sequence of values. A vector is created using the ```c()``` function. For example, let's make a vector with some arbitrary numeric values:

```{r}
# makes vector with values 5,7,55,32
c(5, 7, 55, 32)
```

If we plan to work with this numeric vector again later in our workflow, it makes sense to assign it to an object, which we'll call ```arbitrary_values```:

```{r}
# assigns vector of arbitrary values to new object named "arbitrary_values"
arbitrary_values<-c(5,7,55.6,32.5)
```

Now, whenever we want to print the vector assigned to the ```arbitrary_values``` object, we can simply print the name of the object:

```{r}
# prints vector assigned to "arbitrary_values" object
arbitrary_values
```

It is possible to carry out mathematical operations with numeric vectors; for instance, let's say that we want to double the values in the ```arbitrary_values``` vector; to do so, we can simply multiply ```arbitrary_values``` by 2, which yields a new vector where each numeric element is twice the corresponding element in ```arbitrary_values```. Below, we'll create a new vector that doubles the values in ```arbitrary_values```, assign it to a new object named ```arbitrary_values_2x```, and print the contents of ```arbitrary_values_2x```:

```{r}
# creates a new vector that doubles the values in "arbitrary_values" and assigns it to a new object named
"arbitrary_values_2x"
arbitrary_values_2x<-arbitrary_values*2

# prints contents of "arbitrary_values_2x"
arbitrary_values_2x
```

Now, let's say we want to add different vectors together; the code below creates a new vector by adding together ```arbitrary_values``` and ```arbitrary_values_2x```:

```{r}
# adds "arbitrary_values" vector and "arbitrary_values_2x" vector
arbitrary_values + arbitrary_values_2x
```

Note that each element of the resulting vector printed above is the sum of the corresponding elements in ```arbitrary_values``` and ```arbitrary_values_2x```.

Other arithmetic operations on numeric vectors are also possible, and you may wish to explore these on your own as an exercise. 

In many cases, it is useful to extract a specific element from a vector. Each element in a given vector is assigned an index number, starting with 1; that is, the first element in a vector is assigned an index value of 1, the second element of a vector is assigned an index value of 2, and so on. We can use these index values to extract our desired vector elements. In particular, we can specify the desired index within square brackets after printing the name of the vector object of interest. For example, let's say we want to extract the 3rd element of the vector in ```arbitrary_values```. We can do so with the following:

```{r}
# extracts third element of "arbitrary_values_2x" vector
arbitrary_values[3]
```

It is also possible to extract a range of values from a vector using index values. For example, let's say we want to extract a new vector comprised of the second, third, and fourth numeric elements in ```arbitrary_values```; we can do so with the following:

```{r}
# extracts a new vector comprised of the 2nd, 3rd, and 4th elements of the existing "arbitrary_values" vector
arbitrary_values[2:4]
```

Thus far, we have been working with numeric vectors, where each of the vector's elements is a numeric value, but it is also possible to create vectors in which the elements are strings (i.e. text). Such vectors are know as character vectors. For example, the code below creates a character vector of the first four months of the year, and assigns it to a new object named ```months_four```:

```{r}
# creates character vector whose elements are the first four months of the year, and assigns the vector to a new object named "months_four"
months_four<-c("January", "February", "March", "April")
```

Let's now print the character vector assigned to ```months_four```: 

```{r}
# prints contents of "months_four"
months_four
```

We can extract elements from character vectors using index values in the same way we did so for elements in a numeric vector. For example:

```{r}
# extracts second element of "months_four" object (i.e. the "February" string)
months_four[2]
```

```{r}
# subsets the second and third elements of "months_four" object (i.e. the "February" and "March" strings, which are extracted as a new character vector)
months_four[2:3]
```

## Data Frames


The data frame structure is the workhorse of data analysis in R. A data frame resembles a table, of the sort you might generate in a spreadsheet application. 

Often, the most important (and arduous) step in a data analysis workflow is to assemble disparate strands of data into a tractable data frame. What does it mean for a data frame to be "tractable"? One way to define this concept more precisely is to appeal to the concept of "tidy" data, which is [often referenced in the data science world](https://vita.had.co.nz/papers/tidy-data.pdf). Broadly speaking, a "tidy" data frame is a table in which:

1. Each variable has its own column
2. Each observation has its own row
3. Each value has its own cell

We will work extensively with data frames later in the workshop, but let's generate a simple data frame from scratch, and assign it to a new object. We will generate a data frame containing "dummy" country-level data on basic economic, geographic, and demographic variables, and assign it to a new object named ```country_df```. The data frame is created through the use of the ```data.frame()``` function, which has already been programmed into R. Column names and the corresponding column values are passed to the ```data.frame()``` function in the manner below, and the function effectively binds these different columns together into a table:

```{r}
# Creates a dummy country-level data frame 
country_df<-data.frame(Country=c("Country A", "Country B", "Country C"),
                       GDP=c(8000, 30000, 23500),
                       Population=c(2000, 5400, 10000),
                       Continent=c("South America", "Europe", "North America"))
```

To observe the structure of the table, we can print it to the R console by simply printing the name of the object to which it has been assigned:

```{r}
# prints "country_df" data frame to console
country_df
```

One nice feature of R Studio is that instead of simply printing our data frames into the console, we can view a nicely formatted version of our data frame by passing the name of the data frame object through the ```View()``` function. For example, the code below will bring up the ```country_df``` data frame as a new tab in R Studio:

```{r}
# pulls up "country_df" data frame in R Studio data viewer
View(country_df)
```

```{r, echo=F}
country_df %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Note the "tidy" features of this simple data frame: 

1. Each of the variables (i.e. GDP, Population, Continent) has its own column
2. Each of the (country-level) observations has its own row
3. Each of the values (i.e. country-level information about a given variable) has its own distinct cell

We will explore data frames, and the process of extracting information from them, at greater length in subsequent sections. 

## Lists

In R, a list is a data structure that allows us to conveniently store a variety of different objects, of various types. For example, we can use a list to vectors, data frames, visualizations and graphs--basically any R object you can think of! It is also possible to store a list within a list. 

Lists allow us to keep track of the various objects we create, and are therefore a useful data management tool. In addition, lists are very helpful to use when we want to perform iterative operations across multiple objects. 

We can create lists in R using the ```list()``` function; the arguments to this function are the objects that we want to include in the list. In the code below, we'll create a list (assigned to an object named ```example_list```) that contains some of the objects we create earlier in the lesson: the ```arbitrary_values``` vector, the ```months_four``` vector, and the ```country_df``` data frame. 

```{r}
# creates list whose elements are the "arbitrary_values" numeric vector, the "months_four" character vector, and the "country_df" data frame, and assigns it to a new object named "example_list"
example_list<-list(arbitrary_values, months_four, country_df)
```

Now that we've created our list object, let's print out its contents:

```{r}
# prints contents of "example_list"
example_list
```

As you can see, our list contains each of the various specified objects within a single, unified structure. We can access specific elements within a list using the specific index number of the desired element, in much the same way we did for vectors. When extracting a single list element from a list, the convention is to enclose the index number of the desired list element in double square brackets. For example, if we want to extract the country-level data frame from ```example_list```, we can use the following:

```{r}
# extracts country-level data frame from "example_list"; the country-level data frame is the third element in "example_list"
example_list[[3]]
```

If we want to subset a list, and extract more than one list element as a separate list, we can do so by creating a vector of the index values of the desired elements, and enclosing it in single brackets after the name of the list object. For example, if we wanted to generate a new list that contained only the first and third elements of ```example_list``` (the numeric vector of arbitrary values and the data frame), we would use the following syntax:

```{r}
example_list[c(1,3)]
```

While list elements are not automatically named, we can name our list element using the ```names()``` function. The first step to define a character vector of desired names. We can specify any names we'd like but for the sake of illustration, let's say we want to name the first list element "element1", the second list element "element2", and the third list element "element3". Let's create a vector of our desired names, and assign it to an object named ```name_vector```:

```{r}
# creates a character vector of desired names for list elements, and assigns it to a new object named "name_vector"
name_vector<-c("element1", "element2", "element3")
```

Now, we'll assign these names in ```name_vector``` to the list elements in ```example_list``` with the following

```{r}
# assigns names from "name_vector" to list elements in "example_list"
names(example_list)<-name_vector
```

Let's now print the contents of ```example_list```:

```{r}
# prints contents of "example_list"
example_list
```

Note that the list elements now have names attached to them; the first character string in ```name_vector``` is assigned as the name of the first element in ```example_list```, the second character string in ```name_vector``` is assigned as the name of the second element in ```example_list```, and so on. 

Practically speaking, we can now extract list elements using the assigned names. For example, if we want to extract the data frame from ```example_list```, we could do so by its assigned name ("element3"), as follows:

```{r}
# Extracts the data frame from "example_list" by its assigned name
example_list[["element3"]]
```

Note that even after assigning names to list elements, you can still extract elements by their index value, if you would prefer to do so:

```{r}
# # Extracts the "element3" data frame from "example_list" by its index number
example_list[[3]]

```

## Identifying Data Structures

It is useful to be able to quickly identify the data structure of a given object. Indeed, one way that things can go wrong when processing or analyzing data in R is that a given function expects a certain type of data structure as an input, but encounters something else, which will cause the function to throw an error or perform unexpectedly. In such circumstances, it is especially useful to be able to quickly double-check the data structure of a given object. 

We can quickly ascertain this information by passing a given object as an argument to the ```class()``` function, which will provide information about the object's data structure.

For example, let's say we want to confirm that ```example_list``` is indeed a list:

```{r}
# print the data structure of the "example_list" object
class(example_list)
```

Let's take another example:

```{r}
# print the data structure of the "months_four" object
class(months_four)
```

Note that we can read "character", as "character vector". 

Similarly, we can read "numeric" as "numeric vector":

```{r}
# print the data structure of the "arbitrary_values" object
class(arbitrary_values)
```

# Writing Functions

As we mentioned earlier, a function is  a programming construct that takes a set of inputs (also known as arguments), manipulates those inputs/arguments in a specific way (the body of the function), and returns an output that is the product of how those inputs are manipulated in the body of the function. It is much like a recipe, where the recipe's ingredients are analogous to a function's inputs, the instructions about how to combine and process those ingredients are analogous to the body of the function, and the end product of the recipe (for example, a cake) is analogous to the function's output. R packages are essentially pre-written collections of functions organized around a given theme, and for a large number of data processing and analysis tasks, one can rely on these pre-written functions. In some cases, however, you may want to write your own functions from scratch. 

Why might you want to write your own functions?

* Sometimes, there won't be a convenient pre-programmed function available to accomplish a given task, which will require you to write your own custom function. 
* Writing your own functions will allow you to automate your workflows
* Writing functions will allow you to write more concise and readable code.

Writing your own functions can be challenging, but this section will provide you with some basic intuition for how the process works. To develop this intuition, we'll use a very simple example. 

Let's say you have a large collection of temperature data, measured in Fahrenheit, and you want to convert these data to Celsius. Recall that the formula to convert from Fahrenheit to Celsius is the following, where "C" represents temperature in Celsius, and "F" represents temperature in Fahrenheit: 

```{r, eval=F}
# fahrenheit to Celsius formula, where "F" is fahrenheit input
C=(F-32)*(5/9)
```

Recall that at its most basic level, R is a calculator; if for example, we have a Fahrenheit measurement of 55 degrees, we can convert this to Celsius by plugging 55 into the conversion formula:

```{r}
# Converts 55 degrees fahrenheit to Celsius
(55-32)*(5/9)
```

This is easy enough, but if we have a large amount of temperature data that requires processing, we wouldn't want to carry out this calculation using arithmetic operators for each measurement in our data collection; that could quickly become unwieldy and tedious. Instead of repeatedly using arithmetic operators, we can wrap the Fahrenheit-to-Celsius conversion formula into a function:

```{r}
# Generates function that takes fahrenheit value ("fahrenheit_input") and returns a value in Celsius, and assigns the function to an object named "fahrenheit_to_celsius_converter"
fahrenheit_to_celsius_converter<-function(fahrenheit_input){
  celsius_output<-(fahrenheit_input-32)*(5/9)
  return(celsius_output)
}
```

Let's unpack the code above, which we used to create our function:

* We declare that we are creating a new function with the word ```function```; within the parenthesis after ```function```, we specify the function's argument(s). Here, the function's argument is an input named ```fahrenheit_input```. The name of the argument(s) is arbitrary, and can be anything you like; ideally, its name should be informed by relevant context. Here, the argument/input to the function is a temperature value expressed in degrees Fahrenheit, so the name "fahrenheit_input" describes the nature of this input. 
* After enclosing the function's arguments within parentheses, we print a right-facing curly brace ```{```, and then define the body of the function (i.e. the recipe), which specifies how we want to transform this input. In particular, we take ```fahrenheit_input```, subtract 32, and then multiply by 5/9, which transform the input to the celsius temperature scale. We'll tell R to assign this transformed value to a new object, named ```celsius_output```. 
* In the function's final line, ```return(celsius_output)```, we specify the value we want the function to return. Here, we are saying that we want the function to return the value that was assigned to ```celsius_output```. We then close the function by typing a left-facing curly brace below the return statement ```}```.
* Just as we can assign data or visualizations to objects that allow us to subsequently retrieve the outputs of our code, so too with functions. Here, we'll assign the function we have just return to an object named ```fahrenheit_to_celsius_converter```. 

After creating our function by running that code, we can use the newly created ```fahrenheit_to_celsius``` function to perform our Fahrenheit to Celsius transformations. Let's say we have a Fahrenheit value of 68, and want to transform it to Celsius. Instead of the following calculation:

```{r}
# Uses arithmetic operation to convert 68 degrees Fahrenheit to Celsius
(68-32)*(5/9)
```

We can use our function:

```{r}
# Uses "fahrenheit_to_celsius_converter" function to convert 68 degrees Fahrenheit to Celsius
fahrenheit_to_celsius_converter(fahrenheit_input=68)
```

Above, we passed the argument "fahrenheit_input=68" to the ```fahrenheit_to_celsius_converter``` function that we created; the function then took this value (68), plugged it into "fahrenheit_input" within the function and assigned the resulting value to "celsius_output"; it then returned the value of "celsius_output" (20) back to us. 

Let's try another one: 

```{r}
fahrenheit_to_celsius_converter(fahrenheit_input=22)
```

In short, we can specify any value for the "fahrenheit_input" argument; this value will be substituted for "fahrenheit_input" in the expression ```celsius_output<-(fahrenheit_input-32)*(5/9)```, after which the value of ```celsius_output``` will be returned to us. 

Even though the Fahrenheit to Celsius conversion formula is not particularly complex, it is clear that writing a function to perform this calculation is nonetheless more efficient than repeatedly performing the relevant arithmetic operation. As the operations you need to perform on your data become more complex, and the number of times you need to perform those operations increases, the benefits of wrapping those operations into a function become ever-more apparent. 

# Global and Local Environments

# R Packages

# Iteration

Once we have a function written down, it is straightforward to apply that function to multiple inputs in an iterative fashion. For example, let's say you have four different Fahrenheit temperature values that you would like to convert to celsius, using the ```fahrenheit_to_celsius_converter``` we developed above. One option would be to apply the ```fahrenheit_to_celsius_converter``` function to each of the Fahrenheit temperature inputs individually. For example, let's say our Fahrenheit values, which we'd like to convert to celsius, are the following: 45.6, 95.9, 67.8, 43. We could, of course, run these values through the function individually, as below:

```{r}
fahrenheit_to_celsius_converter(fahrenheit_input=45.6)

fahrenheit_to_celsius_converter(fahrenheit_input=95.9)

fahrenheit_to_celsius_converter(fahrenheit_input=67.8)

fahrenheit_to_celsius_converter(fahrenheit_input=43.)
```

This is manageable with a collection of only four Fahrenheit values, but would quickly become tedious if you had a substantially larger set of Fahrenheit temperature values that required conversion. Instead of  manually applying the function to each individual input value, we can instead put these values into a vector, and then iteratively apply the ```fahrenheit_to_celsius_converter``` function to each of these vector elements. 

Let's first assign our Fahrenheit temperature values to a numeric vector object named ```fahrenheit_input_vector```: 

```{r}
# makes a vector out of Fahrenheit values we want to convert, and assigns it to a new object named "fahrenheit_input_vector"
fahrenheit_input_vector<-c(45.6, 95.9, 67.8, 43)
```

Our goal is to also iteratively apply our function to all of these vector elements, and deposit the transformed results into a new vector.  In programming languages, functions are typically applied to to multiple inputs in an iterative fashion using a construct known as a for-loop, which some of you may already be familiar with. R users also frequently use specialized functions (instead of for-loops) to iterate over elements; this is often faster, or at the very least, makes R scripts more readable. One family of these iterative functions is the "Apply" family of functions. A more recent set of functions that facilitate iteration is part of the *tidyverse*, and is found within the [*purrr*](https://purrr.tidyverse.org/) package. These functions are known as ```map()``` functions, and we will use them here to iteratively apply our functions to multiple inputs. 

Let's see how we can use a ```map()``` function to sequentially apply the ```fahrenheit_to_celsius_converter()``` function we created to several different values for the "fahrenheit_input" argument, contained in ```fahrenheit_input_vector```. We'll pass ```fahrenheit_input_vector``` as the first argument to the  ```map_dbl()``` function, and ```fahrenheit_to_celsius_converter``` (i.e. the function we want to apply iteratively to the elements in `the```fahrenheit_input_vector``` ) as the second argument. The result of this operation will be a new "results vector", containing the transformed temperature values for each input in the original vector of Fahrenheit values (```fahrenheit_input_vector```). We'll assign this result/output vector to a new object named ```celsius_outputs_vector```: 

```{r}
# Iteratively applies the "fahrenheit_to_celsius_converter" to celsius input values in "fahrenheit_input_vector" and assigns the resulting vector of converted temperature values to "celsius_ouputs_vector"
celsius_outputs_vector<-map_dbl(fahrenheit_input_vector, fahrenheit_to_celsius_converter)
```

In short, the code above takes ``fahrenheit_input_vector``` (i.e. a vector with the numbers 45.6, 95.9, 67.8, 43), and runs each of these numbers through the ```fahrenheit_converter()``` function, and sequentially deposits the transformed result to the newly created ```celsius_outputs_vector()``` object, which contains the following elements:

```{r}
# prints contents of "celsius_outputs_vector"
celsius_outputs_vector
```

More explicitly, the code that reads ```celsius_outputs_vector<-map_dbl(fahrenheit_input_vector, fahrenheit_converter)``` did the following:

1. Pass 45.6 (the first element in the input vector, ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and place the output (7.555556) as the first element in a new vector of transformed values, named ```celsius_outputs_vector```.
2. Pass 95.9 (the second element in the input vector, ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and deposit the output (35.500000) as the second element in ```celsius_outputs_vector```. 
3. Pass 67.8 (the third element in the input vector,  ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and deposit the output (19.888889) as the third element in ```celsius_outputs_vector```. 
4. Pass 43 (the fourth element in the input vector, ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and deposit the output (6.111111) as the fourth element in ```celsius_outputs_vector```. 

There are a variety of ```map()``` functions from the *purrr* package, and the precise one you should use turns on the number of arguments used by the function (in this example, there is of course only one argument, i.e. "fahrenheit_input"), and the desired class of the output (i.e. numeric vector, character vector, data frame, list etc.). For example, let's say we want to apply the ```fahrenheit_to_celsius_converter``` function iteratively to the input values in ```fahrenheit_input_vector```, but that we want the output values to be stored as a list, rather than as a vector. Instead of using the ```map_dbl()``` function, we can use the ```map()``` function, which always returns outputs as a list. Below, we pass  our input vector (```fahrenheit_input_vector```),  and the function we want to iteratively apply to the elements of the input vector (```fahrenheit_converter```) to the ```map()``` function. We'll assign the output list to a new object named ```celsius_outputs_list```: 

```{r}
# iteratively applies the "fahrenheit_to_celsius_converter" function to the input values in "fahrenheit_input_vector", and assigns the list of celsius output values to a new object named "celsius_outputs_list"
celsius_outputs_list<-map(fahrenheit_input_vector, fahrenheit_to_celsius_converter)
```

Let's print out the list of output values:

```{r}
# prints contents of "celsius_outputs_list"
celsius_outputs_list
```

We can confirm that ```celsius_outputs_list``` is indeed a list using the ```class()``` function that we introduced earlier:

```{r}
# checks data structure of "celsius_outputs_list"
class(celsius_outputs_list)
```

Now, let's say we  we want to organize our information in a data frame, where one column represents our Fahrenheit input values, and the other column represents the corresponding Celsius output values. To do so, we'll first  slightly modify our function to return a data frame:

```{r}
# Creates function that takes an input value in degrees Fahrenheit (fahrenheit_input), converts this value to Celsius, and returns a data frame with the input Fahrenheit temperature value as one column, and the corresponding Celsius temperature value as another column; the function is assigned to a new object named "fahrenheit_to_celsius_converter_df" 
fahrenheit_to_celsius_converter_df<-function(fahrenheit_input){
  celsius_output<-(fahrenheit_input-32)*(5/9)
  celsius_output_df<-data.frame(fahrenheit_input, celsius_output)
  return(celsius_output_df)
}
```

Now, let's test out this new function for a single "fahrenheit_input" value, to make sure it works as expected; we'll test it out for a value of 63 degrees Fahrenheit:

```{r}
# applies "fahrenheit_to_celsius_converter_df" function to input value of 63 degrees Fahrenheit
fahrenheit_to_celsius_converter_df(fahrenheit_input=63)
```

Having confirmed that the function works as expected, let's now assemble a dataset using multiple Fahrenheit input values, where one column consists of these input values, and the second column consists of the corresponding Celsius outputs. We can do so using the ```map_dfr()``` function from the *purrr* package, which is a cousin of the ```map()``` and ```map_dbl()``` functions we explored above. While the ```map()``` function returns function outputs in a list, and the ```map_dbl()``` function returns function outputs in a numeric vector, the ```map_dfr()``` is used to bind together multiple function outputs rowwise into a data frame. To make this more concrete, let's consider the code below, which uses ```map_dfr()``` to iteratively apply the ```fahrenheit_to_celsius_converter_df``` function to the Fahrenheit values in ```fahrenheit_input_vector```, and assemble the resulting rows into a data frame that is assigned to a new object named ```celsius_outputs_df```:

```{r}
# Iteratively applies the "fahrenheit_to_celsius_converter_df" function to input values in "fahrenheit_input_vector" to generate a data frame with column of input Fahrenheit values, and column of corresponding output Celsius values; assigns this data frame to a new object named "celsius_outputs_df"
celsius_outputs_df<-map_dfr(fahrenheit_input_vector, fahrenheit_to_celsius_converter_df)
```

Let's now print the contents of ```celsius_outputs_df```:

```{r}
# prints contents of 
celsius_outputs_df
```

We now have a dataset with one column consisting of our Fahrenheit inputs (taken from ```fahrenheit_input_vector```), and a second column consisting of our Celsius outputs (derived by applying the ```fahrenheit_to_celsius_converter_df()``` function to our vector of input values, ````fahrenheit_input_vector```). 

We've just covered three different *purrr* functions: ```map()``` (which returns a list), ```map_dbl()``` (which returns a vector), and ```map_dfr()``` (which returns a dataframe). There are other map functions which return different types of objects; you can see a list of these other map functions by inspecting the documentation for the ```map()``` function:

```{r}
?map
```

The process of iteratively applying a function with more than one argument is beyond the scope of the workshop, but the same general principles are at work in those cases. If you'd like to explore the process of iteratively applying a function with two arguments, or more than two arguments, check out the documentation for the ```map2()``` and ```pmap()``` functions, respectively.

Before we move into the next section, let's consider one more example of how you can use your own custom-written functions in conjunction with the iteration functions in the *purrr* package to write scripts that can help you to automate tedious tasks. In particular, we'll demonstrate the utility of the list data structure in helping you to carry out such automation tasks. 

Let's say, for example, that you have temperature values stored in Fahrenheit, for multiple countries, and want to quickly convert those country-level values to degrees Celsius. Suppose that these Fahrenheit values are stored in a series of vectors:

```{r}
# creates sample country-level Fahrenheit data for Country A
countryA_fahrenheit<-c(55,67,91,23, 77, 98, 27)

# creates sample country-level Fahrenheit data for Country B
countryB_fahrenheit<-c(33,45,11,66, 44)

# creates sample country-level Fahrenheit data for Country C
countryC_fahrenheit<-c(60,55,12,109)

# creates sample country-level Fahrenheit data for Country D
countryD_fahrenheit<-c(76, 24, 77, 78)
```

Let's say that we want to take all of these vectors, and iteratively pass them as arguments to the ```fahrenheit_to_celsius_converter_df```  function, thereby creating four country-specific data frames that have the original Fahrenheit values in one column and the transformed Celsius values in the other column. The easiest way to do this is to first put our input vectors into a list, which we'll assign to a new object named ```temperature_input_list```: 

```{r}
# Creates list of input vectors and assigns this list to new object named "input_list"
temperature_input_list<-list(countryA_fahrenheit, countryB_fahrenheit, countryC_fahrenheit, countryD_fahrenheit) 
```

Now, we'll use the ```map()``` function to iteratively pass the vectors in ```temperature_input_list``` as arguments to the ```fahrenheit_to_celsius_converter_df``` function, and deposits the resulting data frames into a list; we'll assign this list that contains the output data frames to a new list object, named ```processed_temperature_data_list```:

```{r}
# Iteratively passes vectors in "temperature_input_list" as arguments to "fahrenheit_to_celsius_converter_df" and deposits the resulting data frames to a list, which is assigned to a new object named "processed_temperature_data_list"
processed_temperature_data_list<-map(temperature_input_list, fahrenheit_to_celsius_converter_df)
```

In effect, the code above takes the ```countryA_fahrenheit``` vector, uses it as the argument to the ```fahrenheit_to_celsius_converter_df``` function, and deposits the resulting data frame as the first element in the ```processed_temperature_data_list``` list; it then takes the ```countryB_fahrenheit``` vector, uses it as the argument to the ```fahrenheit_to_celsius_converter_df``` function, and deposits the resulting data frame as the second element in the ```processed_temperature_data_list``` list; and so on.

Let's print the contents of ```processed_temperature_data_list``` and confirm that our data frames have been created as expected:

```{r}
# prints contents of "processed_temperature_data_list"
processed_temperature_data_list
```

As an exercise, try and extract a given dataset from ```processed_temperature_data_list``` using the indexing method we discussed above. Additionally, see if you can assign names to the list elements in ```processed_temperature_data_list```. 


