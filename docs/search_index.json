[["index.html", "An R Primer for Social Scientists 1 Introduction", " An R Primer for Social Scientists Aditya Ranganath 2024-05-19 1 Introduction This workshop, sponsored by the Institute for Behavioral Science (IBS) and the Center for Research Data and Digital Scholarship (CRDDS) at the University of Colorado Boulder, explore important principles and tools for working with data in R. Its goal is not to provide a comprehensive introduction to the R language, but to provide a practical and example-driven discussion that serves as a starting point for your own exploration. Topics covered include: R as a calculator Object/Variable assignment Data structures Writing basic custom functions Iteration using the purrr package Importing and exporting data from R Functions for wrangling, visualizing, and processsing numeric data Automating basic data workflows using custom functions and iteration The workshop is designed for R beginners, and would be especially helpful for researchers who are interested in transitioning from proprietary data analysis packages such as SPSS and Stata into R. "],["preliminaries.html", "2 Preliminaries 2.1 R and RStudio Installation 2.2 The RStudio Interface 2.3 Install Packages 2.4 Load libraries", " 2 Preliminaries In this preliminary section, we’ll cover basic information that will help you to get started with RStudio. 2.1 R and RStudio Installation If you haven’t already, please go ahead and install both the R and RStudio applications. R and RStudio must be installed separately; you should install R first, and then RStudio. The R application is a bare-bones computing environment that supports statistical computing using the R programming language; RStudio is a visually appealing, feature-rich, and user-friendly interface that allows users to interact with this environment in an intuitive way. Once you have both applications installed, you don’t need to open up R and RStudio separately; you only need to open and interact with RStudio (which will run R in the background). Please follow these instructions to download R and R Studio; make sure you download the version of R appropriate for your operating system. 2.2 The RStudio Interface Now that we’ve installed and opened up RStudio, let’s familiarize ourselves with the RStudio interface. When we open up RStudio, we’ll see a window that looks something like this: Figure 2.1: The RStudio Interface If your interface doesn’t look exactly like this, it shouldn’t be a problem; we would expect to see minor cosmetic differences in the appearance of the interface across operating systems and computers (based on how they’re configured). However, you should see four distinct windows within the larger RStudio interface: The top-left window is known as the Source window. The Source window is where we can write our R scripts (including the code associated with this tutorial), and execute those scripts. We can also type in R code into the “Console” window (bottom-left window), but it is preferable to write our code in a script within the source window. That’s because scripts can be saved (while code written into the console cannot); writing scripts therefore allows us to keep track of what we’re doing, and facilitates the reproducibility of our work. Note that in some cases, we may not see a Source window when we first open RStudio. In that case, to start a new script, simply click the File button on the RStudio menu bar, scroll down to New File button, and then select R Script from the menu bar that opens up. It’s also worth noting that the outputs of certain functions will appear in the Source window. In the context of our tutorial, when we want to view our datasets, we will use the View() function, which will display the relevant data within a new tab in the Source window. The top-right window is the Environment/History pane of the RStudio interface. The “Environment” tab of this window provides information on the datasets we’ve loaded into RStudio, as well as objects we have defined (we’ll talk about objects more later in the tutorial). -The “History” tab of the window provides a record of the R commands we’ve run in a given session. The bottom-right window is the Files/Plots/Packages/Help/Viewer window. The “Files” tab displays our computer’s directories and file structures and allows us to navigate through them without having to leave the R environment. The “Plots” tab is the tab where we can view any visualizations that we create. Within the “Plots” tab, make note of the “Zoom” button, which we can use to enlarge the display of our visualizations if they’re too compressed in the “Plots” window. Also, note the “Export” button within the “Plots” tab (next to the “Zoom” button); we can use this button to export the displayed visualization to a .png or .jpeg file that can be used outside of RStudio. The “Packages” tab provides information on which packages have been installed, as well as which packages are currently loaded (more on packages in Sections 2.3 and 2.4 below) The “Help” tab displays documentation for R packages and functions. If you want to know more about how a package or function work, we can simply type a “?” followed by the package or function’s name (no space between the question mark and the name) and relevant information will be displayed within the “Help” tab. The “Viewer” tab displays HTML output. If we write code that generates an HTML file, we can view it within the “Viewer” tab. The bottom-left window is the Console/Terminal/Jobs window. The “Console” tab is where we can see our code execute when we run our scripts, as well as certain outputs produced by those scripts. In addition, if there are any error or warning messages, they will be printed to the “Console” tab. We can also type code directly into the console, but as we noted earlier, it is better practice to write our code in a script and then run it from there. The “Terminal”, “Jobs” tabs are not relevant for our workshop. We’ll briefly provide an overview of “R Markdown” towards the end of the lesson. 2.3 Install Packages R is an open-source programming language for statistical computing that allows users to carry out a wide range of data analysis and visualization tasks (among other things). One of the big advantages of using R is that it has a very large user community among social scientists, statisticians, and digital humanists, who frequently publish R packages. One might think of packages as workbooks of sorts, which contain a well-integrated set of R functions, scripts, data, and documentation; these “workbooks” are designed to facilitate certain tasks or implement useful procedures. These packages are then shared with the broader R user community, and at this point, anyone who needs to accomplish the tasks to which the package addresses itself can use the package in the context of their own projects. The ability to use published packages considerably simplifies the work of applied data research using R; it means that we rarely have to write code entirely from scratch, and can build on the code that others have published in the form of packages. This allows applied researchers to focus on substantive problems, without having to get too bogged down in complicated programming tasks. In this workshop, we will use the following packages to carry out relevant data analysis and visualization tasks (please click the relevant link to learn more about a given package; note that the tidyverse is not a single package, but rather an entire suite of packages used for common data science and analysis tasks): + tidyverse: + wosr To install a package in R, we can use the install.packages() function. A function is essentially a programming construct that takes a specified input, runs this input (called an “argument”) through a set of procedures, and returns an output. In the code block below, the name of the package we want to install (here, the tidyverse suite) is enclosed within quotation marks and placed within parentheses after printing install.packages Running the code below will effectively download the tidyverse suite of packages to our computer: # Installs &quot;tm&quot; package install.packages(&quot;tidyverse&quot;) To run this code in your own R session: First, copy the code from the codeblock above (you can copy the code to your clipboard by hovering over the top-right of the code-block and clicking the “copy” icon; you can also highlight the code and copy from the Edit menu of your browser). Then, start a new R script within RStudio; if you want to keep a future record of your work, you may want to save this script to your computer (perhaps in the same folder to which you downloaded the tutorial data). We can save our scripts via the RStudio “File” menu. Paste the code into the script, highlight it, and click the “Run” button that is just above the Source window. Alternatively, instead of copying/pasting, you can manually type in the code from the codeblock into your script (manually typing in the code is slower, but often a better way to learn than copy/pasting). After you’ve run the code, watch the code execute in the console, and look for a message confirming that the package has been successfully installed. Below, we can see how that line of code should look in your script, and how to run it: Figure 2.2: Installing tidyverse in R Script Please note that you can follow along with the tutorial on your own computers by transferring all of the subsequent codeblocks into your script in just this way. Run each codeblock in your RStudio environment as you go, and you should be able to replicate the entire tutorial on your computer. You can copy-paste the workshop code if you wish, but we recommend actually retyping the code into your script, since this will help you to more effectively familiarize yourself with the process of writing code in R. Note that the codeblocks in the tutorial usually have a comment, prefaced by a hash (“#”). When writing code in R (or any other command-line interface) it is good practice to preface one’s code with brief comments that describe what a block of code is doing. Writing these comments can allow someone else (or your future self) to read and quickly understand the code more easily than otherwise might be the case. The hash before the comment effectively tells R that the subsequent text is a comment, and should be ignored when running a script. If one does not preface the comment with a hash, R wouldn’t know to ignore the comment, and would throw an error message. Now, let’s install the other packages we mentioned above, using the same install.packages() function: install.packages(&quot;psych&quot;) install.packages(&quot;fastDummies&quot;) install.packages(&quot;janitor&quot;) All of the packages we need are now installed! Note that it’s also possible to install multiple packages in a single command by passing the names of the packages you wish to install to the install.packages() function as a vector, which is created with the c() function: # installs multiple packages using a vector install.packages(c(&quot;psych&quot;, &quot;fastDummies&quot;, &quot;janitor&quot;)) 2.4 Load libraries However, while our packages are installed, they are not yet ready to use. Before we can use our packages, we must load them into our environment. We can think of the process of loading installed packages into a current R environment as analogous to opening up an application on your phone or computer after it has been installed (even after an application has been installed, you can’t use it until you open it!). To load (i.e. “open”) an R package, we pass the name of the package we want to load as an argument to the library() function. For example, if we want to load our tidyverse packages into the current environment, we can type: # Loads tidyverse packages into memory library(tidyverse) At this point, the full suite of the tidyverse suite’s functionality is available for us to use. Now, let’s go ahead and load the remainder of the packages that we’ll need: # loads remainder of required packages library(psych) library(fastDummies) library(janitor) library(stargazer) library(gtsummary) At this point, the packages are loaded and ready to go! One important thing to note regarding the installation and loading of packages is that we only have to install packages once; after a package is installed, there is no need to subsequently reinstall it. However, we must load the packages we need (using the library function) every time we open a new R session. In other words, if we were to close RStudio at this point and open it up later, we would not need to install these packages again, but would need to load the packages again. "],["r-as-a-calculator.html", "3 R as a Calculator", " 3 R as a Calculator At its most basic, R can be used as a calculator. For instance: # calculates 2+2 2+2 ## [1] 4 # calculates 65 to the power of 4 65^4 ## [1] 17850625 While this is a useful starting point, the possibility of assigning values to objects (or variables) considerably increases the scope of the operations we are able to carry out. We turn to object assignment in the next sub-section. "],["object-assignment-and-manipulation.html", "4 Object assignment and manipulation", " 4 Object assignment and manipulation The concept of object (or variable) assignment is a fundamental concept when working in a scripting environment; indeed, the ability to easily assign values to objects is what allows us to easily and intuitively manipulate and process our data in a programmatic setting. To better understand the mechanics of object assignment, consider the following: # assign value 5 to new object named x x&lt;-5 In the code above, we use R’s assignment operator, &lt;-, to assign the value 5 to an object named x. Now that an object named x has been created and assigned the value 5, printing x in our console (or printing x in our script and running it) will return the value that has been assigned to the x object, i.e. 5: # prints value assigned to &quot;x&quot; x ## [1] 5 More generally, the process of assignment effectively equates the output created by the code on the right side of the assignment operator (&lt;-) to an object with a name that is specified on the left side of the assignment operator. Whenever we want to look at the contents of an object (i.e. the output created by the code to the right side of the assignment operator), we simply print the name of the object in the R console (or print the name and run it within a script). Let’s create another object, named y, and assign it the value “12”: # assign value 12 to new object named y y&lt;-12 As we noted above, we can print the value that was assigned to y by printing its name: # prints value assigned to &quot;y&quot; y ## [1] 12 It’s possible to use existing objects to assign values to new ones. For example, we can assign the sum of x and y to a new object that we’ll name xy_sum: # creates a new object, named &quot;xy_sum&quot; whose value is the sum of &quot;x&quot; and &quot;y&quot; xy_sum&lt;-x+y Now, let’s print the contents of xy_sum # prints contents of &quot;xy_sum&quot; xy_sum ## [1] 17 As expected, we see that the value assigned to xy_sum is “17” (i.e. the sum of the values assigned to x and y). It is possible to change the value assigned to a given object. For example, let’s say we want to change the value assigned to x from “5” to “8”: # assign value of &quot;8&quot; to object named &quot;x&quot; x&lt;-8 We can now confirm that x is now associated with the value “8” # prints updated value of &quot;x&quot; x ## [1] 8 It’s worth noting that updating the value assigned to x will not automatically update the value assigned to xy_sum (which, recall, is the sum of x and y). If we print the value assigned to xy_sum, note that it is still “17”): xy_sum ## [1] 17 In order for the value assigned to xy_sum to be updated with the new value of x, we must run the assignment operation again: # assigns sum of &quot;y&quot; and newly updated value of &quot;x&quot; to &quot;xy_sum&quot; object xy_sum&lt;-x+y Now, the value of xy_sum should reflect the updated value of x, which we can confirm by printing the value of xy_sum: # prints value of &quot;xy_sum&quot; xy_sum ## [1] 20 Note that the value assigned to xy_sum is now “20” (the sum of “8” and “12”), rather than “17” (the sum of “5” and “12”). While the examples above were very simple, we can assign virtually any R code, and by extension, the data structure(s) generated by that code (such as datasets, vectors, graphs/plots etc.) to an R object. When naming your objects, try to be descriptive, so that the name of the object signifies something about its corresponding value. Below, consider a simple example of an object, named our_location that has been assigned a non-numeric value. It’s value is a string, or textual information: # assigns text string &quot;Boulder, CO&quot; to our_location&lt;-&quot;Boulder, CO&quot; We can print string that has been assigned to the location object by typing the name of the object in our console, or running it from our script: # prints value of &quot;our_location&quot; object our_location ## [1] &quot;Boulder, CO&quot; Note that generally speaking, you have a lot of flexibility in naming your R objects, but there are certain rules. For example, object names must start with a letter, and cannot contain any special symbols (they can only contain letters, numbers, underscores, and periods). Also, object names cannot contain multiple unconnected words; if you’d like to use multiple words or phrases, connect the discrete elements with an underscore (_), or use camel case (where different words are distinguished by beginning each discrete word begins with a capitalized letter). It is also worth emphasizing that object names are case sensitive; in order to print the value assigned to an object, that object’s name must be printed exactly as it was created. For example, if we were to type our_Location, we would get an error, since there is no our_Location object (only an our_location object): our_Location ## Error in eval(expr, envir, enclos): object &#39;our_Location&#39; not found "],["data-structures.html", "5 Data Structures 5.1 Vectors 5.2 Data Frames 5.3 Lists 5.4 Identifying Data Structures", " 5 Data Structures We now turn to a brief overview of some important data structures that help us to work with data in R. We will consider three data structures that are particularly useful: vectors, data frames, and lists. Note that this is not an exhaustive treatment of data structures in R; there are other structures, such as matrices and arrays, that are also important. However, we will limit our discussion to the data structures that are essential for getting started with data-based social scientific research in R. 5.1 Vectors In R, a vector is a sequence of values. A vector is created using the c() function. For example, let’s make a vector with some arbitrary numeric values: In R, a vector is a sequence of values. A vector is created using the c() function. For example, let’s make a vector with some arbitrary numeric values: # makes vector with values 5,7,55,32 c(5, 7, 55, 32) ## [1] 5 7 55 32 If we plan to work with this numeric vector again later in our workflow, it makes sense to assign it to an object, which we’ll call arbitrary_values: # assigns vector of arbitrary values to new object named &quot;arbitrary_values&quot; arbitrary_values&lt;-c(5,7,55.6,32.5) Now, whenever we want to print the vector assigned to the arbitrary_values object, we can simply print the name of the object: # prints vector assigned to &quot;arbitrary_values&quot; object arbitrary_values ## [1] 5.0 7.0 55.6 32.5 It is possible to carry out mathematical operations with numeric vectors; for instance, let’s say that we want to double the values in the arbitrary_values vector; to do so, we can simply multiply arbitrary_values by 2, which yields a new vector where each numeric element is twice the corresponding element in arbitrary_values. Below, we’ll create a new vector that doubles the values in arbitrary_values, assign it to a new object named arbitrary_values_2x, and print the contents of arbitrary_values_2x: # creates a new vector that doubles the values in &quot;arbitrary_values&quot; and assigns it to a new object named &quot;arbitrary_values_2x&quot; ## [1] &quot;arbitrary_values_2x&quot; arbitrary_values_2x&lt;-arbitrary_values*2 # prints contents of &quot;arbitrary_values_2x&quot; arbitrary_values_2x ## [1] 10.0 14.0 111.2 65.0 Now, let’s say we want to add different vectors together; the code below creates a new vector by adding together arbitrary_values and arbitrary_values_2x: # adds &quot;arbitrary_values&quot; vector and &quot;arbitrary_values_2x&quot; vector arbitrary_values + arbitrary_values_2x ## [1] 15.0 21.0 166.8 97.5 Note that each element of the resulting vector printed above is the sum of the corresponding elements in arbitrary_values and arbitrary_values_2x. Other arithmetic operations on numeric vectors are also possible, and you may wish to explore these on your own as an exercise. In many cases, it is useful to extract a specific element from a vector. Each element in a given vector is assigned an index number, starting with 1; that is, the first element in a vector is assigned an index value of 1, the second element of a vector is assigned an index value of 2, and so on. We can use these index values to extract our desired vector elements. In particular, we can specify the desired index within square brackets after printing the name of the vector object of interest. For example, let’s say we want to extract the 3rd element of the vector in arbitrary_values. We can do so with the following: # extracts third element of &quot;arbitrary_values_2x&quot; vector arbitrary_values[3] ## [1] 55.6 It is also possible to extract a range of values from a vector using index values. For example, let’s say we want to extract a new vector comprised of the second, third, and fourth numeric elements in arbitrary_values; we can do so with the following: # extracts a new vector comprised of the 2nd, 3rd, and 4th elements of the existing &quot;arbitrary_values&quot; vector arbitrary_values[2:4] ## [1] 7.0 55.6 32.5 Thus far, we have been working with numeric vectors, where each of the vector’s elements is a numeric value, but it is also possible to create vectors in which the elements are strings (i.e. text). Such vectors are know as character vectors. For example, the code below creates a character vector of the first four months of the year, and assigns it to a new object named months_four: # creates character vector whose elements are the first four months of the year, and assigns the vector to a new object named &quot;months_four&quot; months_four&lt;-c(&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;) Let’s now print the character vector assigned to months_four: # prints contents of &quot;months_four&quot; months_four ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; We can extract elements from character vectors using index values in the same way we did so for elements in a numeric vector. For example: # extracts second element of &quot;months_four&quot; object (i.e. the &quot;February&quot; string) months_four[2] ## [1] &quot;February&quot; # subsets the second and third elements of &quot;months_four&quot; object (i.e. the &quot;February&quot; and &quot;March&quot; strings, which are extracted as a new character vector) months_four[2:3] ## [1] &quot;February&quot; &quot;March&quot; 5.2 Data Frames The data frame structure is the workhorse of data analysis in R. A data frame resembles a table, of the sort you might generate in a spreadsheet application. Often, the most important (and arduous) step in a data analysis workflow is to assemble disparate strands of data into a tractable data frame. What does it mean for a data frame to be “tractable”? One way to define this concept more precisely is to appeal to the concept of “tidy” data, which is often referenced in the data science world. Broadly speaking, a “tidy” data frame is a table in which: Each variable has its own column Each observation has its own row Each value has its own cell We will work extensively with data frames later in the workshop, but let’s generate a simple data frame from scratch, and assign it to a new object. We will generate a data frame containing “dummy” country-level data on basic economic, geographic, and demographic variables, and assign it to a new object named country_df. The data frame is created through the use of the data.frame() function, which has already been programmed into R. Column names and the corresponding column values are passed to the data.frame() function in the manner below, and the function effectively binds these different columns together into a table: # Creates a dummy country-level data frame country_df&lt;-data.frame(Country=c(&quot;Country A&quot;, &quot;Country B&quot;, &quot;Country C&quot;), GDP=c(8000, 30000, 23500), Population=c(2000, 5400, 10000), Continent=c(&quot;South America&quot;, &quot;Europe&quot;, &quot;North America&quot;)) To observe the structure of the table, we can print it to the R console by simply printing the name of the object to which it has been assigned: # prints &quot;country_df&quot; data frame to console country_df ## Country GDP Population Continent ## 1 Country A 8000 2000 South America ## 2 Country B 30000 5400 Europe ## 3 Country C 23500 10000 North America One nice feature of R Studio is that instead of simply printing our data frames into the console, we can view a nicely formatted version of our data frame by passing the name of the data frame object through the View() function. For example, the code below will bring up the country_df data frame as a new tab in R Studio: # pulls up &quot;country_df&quot; data frame in R Studio data viewer View(country_df) Note the “tidy” features of this simple data frame: Each of the variables (i.e. GDP, Population, Continent) has its own column Each of the (country-level) observations has its own row Each of the values (i.e. country-level information about a given variable) has its own distinct cell We will explore data frames, and the process of extracting information from them, at greater length in subsequent sections. 5.3 Lists In R, a list is a data structure that allows us to conveniently store a variety of different objects, of various types. For example, we can use a list to vectors, data frames, visualizations and graphs–basically any R object you can think of! It is also possible to store a list within a list. Lists allow us to keep track of the various objects we create, and are therefore a useful data management tool. In addition, lists are very helpful to use when we want to perform iterative operations across multiple objects. We can create lists in R using the list() function; the arguments to this function are the objects that we want to include in the list. In the code below, we’ll create a list (assigned to an object named example_list) that contains some of the objects we create earlier in the lesson: the arbitrary_values vector, the months_four vector, and the country_df data frame. # creates list whose elements are the &quot;arbitrary_values&quot; numeric vector, the &quot;months_four&quot; character vector, and the &quot;country_df&quot; data frame, and assigns it to a new object named &quot;example_list&quot; example_list&lt;-list(arbitrary_values, months_four, country_df) Now that we’ve created our list object, let’s print out its contents: # prints contents of &quot;example_list&quot; example_list ## [[1]] ## [1] 5.0 7.0 55.6 32.5 ## ## [[2]] ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; ## ## [[3]] ## Country GDP Population Continent ## 1 Country A 8000 2000 South America ## 2 Country B 30000 5400 Europe ## 3 Country C 23500 10000 North America As you can see, our list contains each of the various specified objects within a single, unified structure. We can access specific elements within a list using the specific index number of the desired element, in much the same way we did for vectors. When extracting a single list element from a list, the convention is to enclose the index number of the desired list element in double square brackets. For example, if we want to extract the country-level data frame from example_list, we can use the following: # extracts country-level data frame from &quot;example_list&quot;; the country-level data frame is the third element in &quot;example_list&quot; example_list[[3]] ## Country GDP Population Continent ## 1 Country A 8000 2000 South America ## 2 Country B 30000 5400 Europe ## 3 Country C 23500 10000 North America If we want to subset a list, and extract more than one list element as a separate list, we can do so by creating a vector of the index values of the desired elements, and enclosing it in single brackets after the name of the list object. For example, if we wanted to generate a new list that contained only the first and third elements of example_list (the numeric vector of arbitrary values and the data frame), we would use the following syntax: example_list[c(1,3)] ## [[1]] ## [1] 5.0 7.0 55.6 32.5 ## ## [[2]] ## Country GDP Population Continent ## 1 Country A 8000 2000 South America ## 2 Country B 30000 5400 Europe ## 3 Country C 23500 10000 North America While list elements are not automatically named, we can name our list element using the names() function. The first step to define a character vector of desired names. We can specify any names we’d like but for the sake of illustration, let’s say we want to name the first list element “element1”, the second list element “element2”, and the third list element “element3”. Let’s create a vector of our desired names, and assign it to an object named name_vector: # creates a character vector of desired names for list elements, and assigns it to a new object named &quot;name_vector&quot; name_vector&lt;-c(&quot;element1&quot;, &quot;element2&quot;, &quot;element3&quot;) Now, we’ll assign these names in name_vector to the list elements in example_list with the following # assigns names from &quot;name_vector&quot; to list elements in &quot;example_list&quot; names(example_list)&lt;-name_vector Let’s now print the contents of example_list: # prints contents of &quot;example_list&quot; example_list ## $element1 ## [1] 5.0 7.0 55.6 32.5 ## ## $element2 ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; ## ## $element3 ## Country GDP Population Continent ## 1 Country A 8000 2000 South America ## 2 Country B 30000 5400 Europe ## 3 Country C 23500 10000 North America Note that the list elements now have names attached to them; the first character string in name_vector is assigned as the name of the first element in example_list, the second character string in name_vector is assigned as the name of the second element in example_list, and so on. Practically speaking, we can now extract list elements using the assigned names. For example, if we want to extract the data frame from example_list, we could do so by its assigned name (“element3”), as follows: # Extracts the data frame from &quot;example_list&quot; by its assigned name example_list[[&quot;element3&quot;]] ## Country GDP Population Continent ## 1 Country A 8000 2000 South America ## 2 Country B 30000 5400 Europe ## 3 Country C 23500 10000 North America Note that even after assigning names to list elements, you can still extract elements by their index value, if you would prefer to do so: # # Extracts the &quot;element3&quot; data frame from &quot;example_list&quot; by its index number example_list[[3]] ## Country GDP Population Continent ## 1 Country A 8000 2000 South America ## 2 Country B 30000 5400 Europe ## 3 Country C 23500 10000 North America 5.4 Identifying Data Structures It is useful to be able to quickly identify the data structure of a given object. Indeed, one way that things can go wrong when processing or analyzing data in R is that a given function expects a certain type of data structure as an input, but encounters something else, which will cause the function to throw an error or perform unexpectedly. In such circumstances, it is especially useful to be able to quickly double-check the data structure of a given object. We can quickly ascertain this information by passing a given object as an argument to the class() function, which will provide information about the object’s data structure. For example, let’s say we want to confirm that example_list is indeed a list: # print the data structure of the &quot;example_list&quot; object class(example_list) ## [1] &quot;list&quot; Let’s take another example: # print the data structure of the &quot;months_four&quot; object class(months_four) ## [1] &quot;character&quot; Note that we can read “character”, as “character vector”. Similarly, we can read “numeric” as “numeric vector”: # print the data structure of the &quot;arbitrary_values&quot; object class(arbitrary_values) ## [1] &quot;numeric&quot; "],["writing-functions.html", "6 Writing Functions", " 6 Writing Functions As we mentioned earlier, a function is a programming construct that takes a set of inputs (also known as arguments), manipulates those inputs/arguments in a specific way (the body of the function), and returns an output that is the product of how those inputs are manipulated in the body of the function. It is much like a recipe, where the recipe’s ingredients are analogous to a function’s inputs, the instructions about how to combine and process those ingredients are analogous to the body of the function, and the end product of the recipe (for example, a cake) is analogous to the function’s output. R packages are essentially pre-written collections of functions organized around a given theme, and for a large number of data processing and analysis tasks, one can rely on these pre-written functions. In some cases, however, you may want to write your own functions from scratch. Why might you want to write your own functions? Sometimes, there won’t be a convenient pre-programmed function available to accomplish a given task, which will require you to write your own custom function. Writing your own functions will allow you to automate your workflows Writing functions will allow you to write more concise and readable code. Writing your own functions can be challenging, but this section will provide you with some basic intuition for how the process works. To develop this intuition, we’ll use a very simple example. Let’s say you have a large collection of temperature data, measured in Fahrenheit, and you want to convert these data to Celsius. Recall that the formula to convert from Fahrenheit to Celsius is the following, where “C” represents temperature in Celsius, and “F” represents temperature in Fahrenheit: # fahrenheit to Celsius formula, where &quot;F&quot; is fahrenheit input C=(F-32)*(5/9) Recall that at its most basic level, R is a calculator; if for example, we have a Fahrenheit measurement of 55 degrees, we can convert this to Celsius by plugging 55 into the conversion formula: # Converts 55 degrees fahrenheit to Celsius (55-32)*(5/9) ## [1] 12.77778 This is easy enough, but if we have a large amount of temperature data that requires processing, we wouldn’t want to carry out this calculation using arithmetic operators for each measurement in our data collection; that could quickly become unwieldy and tedious. Instead of repeatedly using arithmetic operators, we can wrap the Fahrenheit-to-Celsius conversion formula into a function: # Generates function that takes fahrenheit value (&quot;fahrenheit_input&quot;) and returns a value in Celsius, and assigns the function to an object named &quot;fahrenheit_to_celsius_converter&quot; fahrenheit_to_celsius_converter&lt;-function(fahrenheit_input){ celsius_output&lt;-(fahrenheit_input-32)*(5/9) return(celsius_output) } Let’s unpack the code above, which we used to create our function: We declare that we are creating a new function with the word function; within the parenthesis after function, we specify the function’s argument(s). Here, the function’s argument is an input named fahrenheit_input. The name of the argument(s) is arbitrary, and can be anything you like; ideally, its name should be informed by relevant context. Here, the argument/input to the function is a temperature value expressed in degrees Fahrenheit, so the name “fahrenheit_input” describes the nature of this input. After enclosing the function’s arguments within parentheses, we print a right-facing curly brace {, and then define the body of the function (i.e. the recipe), which specifies how we want to transform this input. In particular, we take fahrenheit_input, subtract 32, and then multiply by 5/9, which transform the input to the celsius temperature scale. We’ll tell R to assign this transformed value to a new object, named celsius_output. In the function’s final line, return(celsius_output), we specify the value we want the function to return. Here, we are saying that we want the function to return the value that was assigned to celsius_output. We then close the function by typing a left-facing curly brace below the return statement }. Just as we can assign data or visualizations to objects that allow us to subsequently retrieve the outputs of our code, so too with functions. Here, we’ll assign the function we have just return to an object named fahrenheit_to_celsius_converter. After creating our function by running that code, we can use the newly created fahrenheit_to_celsius function to perform our Fahrenheit to Celsius transformations. Let’s say we have a Fahrenheit value of 68, and want to transform it to Celsius. Instead of the following calculation: # Uses arithmetic operation to convert 68 degrees Fahrenheit to Celsius (68-32)*(5/9) ## [1] 20 We can use our function: # Uses &quot;fahrenheit_to_celsius_converter&quot; function to convert 68 degrees Fahrenheit to Celsius fahrenheit_to_celsius_converter(fahrenheit_input=68) ## [1] 20 Above, we passed the argument “fahrenheit_input=68” to the fahrenheit_to_celsius_converter function that we created; the function then took this value (68), plugged it into “fahrenheit_input” within the function and assigned the resulting value to “celsius_output”; it then returned the value of “celsius_output” (20) back to us. Let’s try another one: fahrenheit_to_celsius_converter(fahrenheit_input=22) ## [1] -5.555556 In short, we can specify any value for the “fahrenheit_input” argument; this value will be substituted for “fahrenheit_input” in the expression celsius_output&lt;-(fahrenheit_input-32)*(5/9), after which the value of celsius_output will be returned to us. Even though the Fahrenheit to Celsius conversion formula is not particularly complex, it is clear that writing a function to perform this calculation is nonetheless more efficient than repeatedly performing the relevant arithmetic operation. As the operations you need to perform on your data become more complex, and the number of times you need to perform those operations increases, the benefits of wrapping those operations into a function become ever-more apparent. "],["iteration.html", "7 Iteration", " 7 Iteration Once we have a function written down, it is straightforward to apply that function to multiple inputs in an iterative fashion. For example, let’s say you have four different Fahrenheit temperature values that you would like to convert to celsius, using the fahrenheit_to_celsius_converter we developed above. One option would be to apply the fahrenheit_to_celsius_converter function to each of the Fahrenheit temperature inputs individually. For example, let’s say our Fahrenheit values, which we’d like to convert to celsius, are the following: 45.6, 95.9, 67.8, 43. We could, of course, run these values through the function individually, as below: fahrenheit_to_celsius_converter(fahrenheit_input=45.6) ## [1] 7.555556 fahrenheit_to_celsius_converter(fahrenheit_input=95.9) ## [1] 35.5 fahrenheit_to_celsius_converter(fahrenheit_input=67.8) ## [1] 19.88889 fahrenheit_to_celsius_converter(fahrenheit_input=43.) ## [1] 6.111111 This is manageable with a collection of only four Fahrenheit values, but would quickly become tedious if you had a substantially larger set of Fahrenheit temperature values that required conversion. Instead of manually applying the function to each individual input value, we can instead put these values into a vector, and then iteratively apply the fahrenheit_to_celsius_converter function to each of these vector elements. Let’s first assign our Fahrenheit temperature values to a numeric vector object named fahrenheit_input_vector: # makes a vector out of Fahrenheit values we want to convert, and assigns it to a new object named &quot;fahrenheit_input_vector&quot; fahrenheit_input_vector&lt;-c(45.6, 95.9, 67.8, 43) Our goal is to also iteratively apply our function to all of these vector elements, and deposit the transformed results into a new vector. In programming languages, functions are typically applied to to multiple inputs in an iterative fashion using a construct known as a for-loop, which some of you may already be familiar with. R users also frequently use specialized functions (instead of for-loops) to iterate over elements; this is often faster, or at the very least, makes R scripts more readable. One family of these iterative functions is the “Apply” family of functions. A more recent set of functions that facilitate iteration is part of the tidyverse, and is found within the purrr package. These functions are known as map() functions, and we will use them here to iteratively apply our functions to multiple inputs. Let’s see how we can use a map() function to sequentially apply the fahrenheit_to_celsius_converter() function we created to several different values for the “fahrenheit_input” argument, contained in fahrenheit_input_vector. We’ll pass fahrenheit_input_vector as the first argument to the map_dbl() function, and fahrenheit_to_celsius_converter (i.e. the function we want to apply iteratively to the elements in `thefahrenheit_input_vector ) as the second argument. The result of this operation will be a new “results vector”, containing the transformed temperature values for each input in the original vector of Fahrenheit values (fahrenheit_input_vector). We’ll assign this result/output vector to a new object named celsius_outputs_vector: # Iteratively applies the &quot;fahrenheit_to_celsius_converter&quot; to celsius input values in &quot;fahrenheit_input_vector&quot; and assigns the resulting vector of converted temperature values to &quot;celsius_ouputs_vector&quot; celsius_outputs_vector&lt;-map_dbl(fahrenheit_input_vector, fahrenheit_to_celsius_converter) In short, the code above takes ``fahrenheit_input_vector(i.e. a vector with the numbers 45.6, 95.9, 67.8, 43), and runs each of these numbers through thefahrenheit_converter()function, and sequentially deposits the transformed result to the newly createdcelsius_outputs_vector()``` object, which contains the following elements: # prints contents of &quot;celsius_outputs_vector&quot; celsius_outputs_vector ## [1] 7.555556 35.500000 19.888889 6.111111 More explicitly, the code that reads celsius_outputs_vector&lt;-map_dbl(fahrenheit_input_vector, fahrenheit_converter) did the following: Pass 45.6 (the first element in the input vector, fahrenheit_input_vector) to the fahrenheit_converter() function, and place the output (7.555556) as the first element in a new vector of transformed values, named celsius_outputs_vector. Pass 95.9 (the second element in the input vector, fahrenheit_input_vector) to the fahrenheit_converter() function, and deposit the output (35.500000) as the second element in celsius_outputs_vector. Pass 67.8 (the third element in the input vector, fahrenheit_input_vector) to the fahrenheit_converter() function, and deposit the output (19.888889) as the third element in celsius_outputs_vector. Pass 43 (the fourth element in the input vector, fahrenheit_input_vector) to the fahrenheit_converter() function, and deposit the output (6.111111) as the fourth element in celsius_outputs_vector. There are a variety of map() functions from the purrr package, and the precise one you should use turns on the number of arguments used by the function (in this example, there is of course only one argument, i.e. “fahrenheit_input”), and the desired class of the output (i.e. numeric vector, character vector, data frame, list etc.). For example, let’s say we want to apply the fahrenheit_to_celsius_converter function iteratively to the input values in fahrenheit_input_vector, but that we want the output values to be stored as a list, rather than as a vector. Instead of using the map_dbl() function, we can use the map() function, which always returns outputs as a list. Below, we pass our input vector (fahrenheit_input_vector), and the function we want to iteratively apply to the elements of the input vector (fahrenheit_converter) to the map() function. We’ll assign the output list to a new object named celsius_outputs_list: # iteratively applies the &quot;fahrenheit_to_celsius_converter&quot; function to the input values in &quot;fahrenheit_input_vector&quot;, and assigns the list of celsius output values to a new object named &quot;celsius_outputs_list&quot; celsius_outputs_list&lt;-map(fahrenheit_input_vector, fahrenheit_to_celsius_converter) Let’s print out the list of output values: # prints contents of &quot;celsius_outputs_list&quot; celsius_outputs_list ## [[1]] ## [1] 7.555556 ## ## [[2]] ## [1] 35.5 ## ## [[3]] ## [1] 19.88889 ## ## [[4]] ## [1] 6.111111 We can confirm that celsius_outputs_list is indeed a list using the class() function that we introduced earlier: # checks data structure of &quot;celsius_outputs_list&quot; class(celsius_outputs_list) ## [1] &quot;list&quot; Now, let’s say we we want to organize our information in a data frame, where one column represents our Fahrenheit input values, and the other column represents the corresponding Celsius output values. To do so, we’ll first slightly modify our function to return a data frame: # Creates function that takes an input value in degrees Fahrenheit (fahrenheit_input), converts this value to Celsius, and returns a data frame with the input Fahrenheit temperature value as one column, and the corresponding Celsius temperature value as another column; the function is assigned to a new object named &quot;fahrenheit_to_celsius_converter_df&quot; fahrenheit_to_celsius_converter_df&lt;-function(fahrenheit_input){ celsius_output&lt;-(fahrenheit_input-32)*(5/9) celsius_output_df&lt;-data.frame(fahrenheit_input, celsius_output) return(celsius_output_df) } Now, let’s test out this new function for a single “fahrenheit_input” value, to make sure it works as expected; we’ll test it out for a value of 63 degrees Fahrenheit: # applies &quot;fahrenheit_to_celsius_converter_df&quot; function to input value of 63 degrees Fahrenheit fahrenheit_to_celsius_converter_df(fahrenheit_input=63) ## fahrenheit_input celsius_output ## 1 63 17.22222 Having confirmed that the function works as expected, let’s now assemble a dataset using multiple Fahrenheit input values, where one column consists of these input values, and the second column consists of the corresponding Celsius outputs. We can do so using the map_dfr() function from the purrr package, which is a cousin of the map() and map_dbl() functions we explored above. While the map() function returns function outputs in a list, and the map_dbl() function returns function outputs in a numeric vector, the map_dfr() is used to bind together multiple function outputs rowwise into a data frame. To make this more concrete, let’s consider the code below, which uses map_dfr() to iteratively apply the fahrenheit_to_celsius_converter_df function to the Fahrenheit values in fahrenheit_input_vector, and assemble the resulting rows into a data frame that is assigned to a new object named celsius_outputs_df: # Iteratively applies the &quot;fahrenheit_to_celsius_converter_df&quot; function to input values in &quot;fahrenheit_input_vector&quot; to generate a data frame with column of input Fahrenheit values, and column of corresponding output Celsius values; assigns this data frame to a new object named &quot;celsius_outputs_df&quot; celsius_outputs_df&lt;-map_dfr(fahrenheit_input_vector, fahrenheit_to_celsius_converter_df) Let’s now print the contents of celsius_outputs_df: # prints contents of celsius_outputs_df ## fahrenheit_input celsius_output ## 1 45.6 7.555556 ## 2 95.9 35.500000 ## 3 67.8 19.888889 ## 4 43.0 6.111111 We now have a dataset with one column consisting of our Fahrenheit inputs (taken from fahrenheit_input_vector), and a second column consisting of our Celsius outputs (derived by applying the fahrenheit_to_celsius_converter_df() function to our vector of input values, `fahrenheit_input_vector). We’ve just covered three different purrr functions: map() (which returns a list), map_dbl() (which returns a vector), and map_dfr() (which returns a dataframe). There are other map functions which return different types of objects; you can see a list of these other map functions by inspecting the documentation for the map() function: ?map The process of iteratively applying a function with more than one argument is beyond the scope of the workshop, but the same general principles are at work in those cases. If you’d like to explore the process of iteratively applying a function with two arguments, or more than two arguments, check out the documentation for the map2() and pmap() functions, respectively. Before we move into the next section, let’s consider one more example of how you can use your own custom-written functions in conjunction with the iteration functions in the purrr package to write scripts that can help you to automate tedious tasks. In particular, we’ll demonstrate the utility of the list data structure in helping you to carry out such automation tasks. Let’s say, for example, that you have temperature values stored in Fahrenheit, for multiple countries, and want to quickly convert those country-level values to degrees Celsius. Suppose that these Fahrenheit values are stored in a series of vectors: # creates sample country-level Fahrenheit data for Country A countryA_fahrenheit&lt;-c(55,67,91,23, 77, 98, 27) # creates sample country-level Fahrenheit data for Country B countryB_fahrenheit&lt;-c(33,45,11,66, 44) # creates sample country-level Fahrenheit data for Country C countryC_fahrenheit&lt;-c(60,55,12,109) # creates sample country-level Fahrenheit data for Country D countryD_fahrenheit&lt;-c(76, 24, 77, 78) Let’s say that we want to take all of these vectors, and iteratively pass them as arguments to the fahrenheit_to_celsius_converter_df function, thereby creating four country-specific data frames that have the original Fahrenheit values in one column and the transformed Celsius values in the other column. The easiest way to do this is to first put our input vectors into a list, which we’ll assign to a new object named temperature_input_list: # Creates list of input vectors and assigns this list to new object named &quot;input_list&quot; temperature_input_list&lt;-list(countryA_fahrenheit, countryB_fahrenheit, countryC_fahrenheit, countryD_fahrenheit) Now, we’ll use the map() function to iteratively pass the vectors in temperature_input_list as arguments to the fahrenheit_to_celsius_converter_df function, and deposits the resulting data frames into a list; we’ll assign this list that contains the output data frames to a new list object, named processed_temperature_data_list: # Iteratively passes vectors in &quot;temperature_input_list&quot; as arguments to &quot;fahrenheit_to_celsius_converter_df&quot; and deposits the resulting data frames to a list, which is assigned to a new object named &quot;processed_temperature_data_list&quot; processed_temperature_data_list&lt;-map(temperature_input_list, fahrenheit_to_celsius_converter_df) In effect, the code above takes the countryA_fahrenheit vector, uses it as the argument to the fahrenheit_to_celsius_converter_df function, and deposits the resulting data frame as the first element in the processed_temperature_data_list list; it then takes the countryB_fahrenheit vector, uses it as the argument to the fahrenheit_to_celsius_converter_df function, and deposits the resulting data frame as the second element in the processed_temperature_data_list list; and so on. Let’s print the contents of processed_temperature_data_list and confirm that our data frames have been created as expected: # prints contents of &quot;processed_temperature_data_list&quot; processed_temperature_data_list ## [[1]] ## fahrenheit_input celsius_output ## 1 55 12.777778 ## 2 67 19.444444 ## 3 91 32.777778 ## 4 23 -5.000000 ## 5 77 25.000000 ## 6 98 36.666667 ## 7 27 -2.777778 ## ## [[2]] ## fahrenheit_input celsius_output ## 1 33 0.5555556 ## 2 45 7.2222222 ## 3 11 -11.6666667 ## 4 66 18.8888889 ## 5 44 6.6666667 ## ## [[3]] ## fahrenheit_input celsius_output ## 1 60 15.55556 ## 2 55 12.77778 ## 3 12 -11.11111 ## 4 109 42.77778 ## ## [[4]] ## fahrenheit_input celsius_output ## 1 76 24.444444 ## 2 24 -4.444444 ## 3 77 25.000000 ## 4 78 25.555556 As an exercise, try and extract a given dataset from processed_temperature_data_list using the indexing method we discussed above. Additionally, see if you can assign names to the list elements in processed_temperature_data_list. "],["data-transfer-part-1-importing-data-into-r-studio.html", "8 Data Transfer Part 1: Importing Data into R Studio 8.1 Reading in a dataset from a directory on your computer 8.2 Reading in multiple datasets from your disk 8.3 Reading in a dataset from cloud storage 8.4 Reading in data from an R package 8.5 Reading in data from a website", " 8 Data Transfer Part 1: Importing Data into R Studio Typically, the first step when working with research data in R Studio is to load your relevant data into memory. There are many ways to do this, and the precise way in which you will do so will depend on where your data is stored, and how it is structured. Below, we’ll cover the process of reading your data into R Studio under a couple of different scenarios. We will be working extensively with a country-level crossnational dataset collected by the political economists Torsten Persson and Guido Tabellini for their book on the Economic Effects of Constitutions. If you’d like to learn more about this dataset, please refer to its codebook In addition, we will also work with four country-level datasets extracted from the World Bank’s World Development Indicators series. These datasets contain information on central government debt as a percentage of GDP; net foreign direct investment inflows as a percentage of GDP; trade as a percentage of GDP; and the urban population as a percentage of the total population. The data for all four of these WDI datasets corresponds to the year 2019. 8.1 Reading in a dataset from a directory on your computer Often (especially when a dataset is of tractable size), you will have the dataset you would like to analyze stored on a directory on your computer. In order to read in a dataset from a computer directory, you can use the read_csv() function (provided it is stored as a CSV; if the file type is different, than the import function would be different as well), and the pass dataset’s file path as an argument to the function. Typically, you will want to assign the dataset you read in to a new R object: # Reads in Persson/Tabellini Data from local directory, and assigns it to new object named &quot;pt&quot; pt&lt;-read_csv(&quot;data/pt/persson_tabellini_workshop.csv&quot;) ## Rows: 85 Columns: 75 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (2): country, continent ## dbl (73): oecd, pind, pindo, ctrycd, col_uk, t_indep, col_uka, col_espa, col_otha, legor_uk, legor_so,... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. If you’d like to view the contents of the dataset, pass it to the R Studio data viewer: # views &quot;pt&quot; data frame in R Studio data viewer View(pt) 8.2 Reading in multiple datasets from your disk Sometimes, your data is spread out over multiple files. For example, you may have multiple CSV files with data stored on disk, which you want to read into R from disk at one-go, instead of loading in multiple files individually. To do so, we can use the list data structure to hold all of the desired files, and use the map() function we learned about above to iteratively read these files into our R environment. The first step is to use the list.files() function to create a character vector of the file names we want to read in; if all of the files you want to read in are already in your working directory, you don’t need to supply any arguments to the list.files() function. If the files are stored in another location, you can specify the relevant file path as an argument to list.files(). In the case below, the individual files we want to read in are four World Development Indicators datasets (which were extracted using the menu on the WDI website); these files are in the “wb” directory within the “data” subdirectory of the working directory: # print relevant file names, which are stored in the data/wos subdirectory wb_files&lt;-list.files(&quot;data/wb&quot;) Let’s now print the contents of “wb_files” and observe the file names”: # prints contents of &quot;wos_files&quot; wb_files ## [1] &quot;wdi_debt2019.csv&quot; &quot;wdi_fdi2019.csv&quot; &quot;wdi_trade2019.csv&quot; &quot;wdi_urban2019.csv&quot; Now that we have our file names, we can iteratively pass them through the read_csv() function, and deposit the files as data frames in a list, which we’ll assign to a new object named wb_file_list: # Iteratively reads in all individual WB files from the &quot;data/db&quot; directory and assigns it to an object named &quot;wb_file_list&quot; setwd(&quot;data/wb&quot;) wb_file_list&lt;-map(wb_files, read_csv) ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. The code above takes the first file name in wb_file_list() and then passes it to the read_csv() function and deposits the file as the first data frame in a new list; it then takes the second file name in wb_file_list() and then passes it to the read_csv() function and deposits that file as the second data frame in the list; and so on. The list containing all of the files is assigned to a new object named wb_file_list; we’ll print the contents below: # prints contents of &quot;wos_file_list&quot; wb_file_list ## [[1]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Central government debt, total (% of … GC.DOD.TOTL.… .. ## 2 Albania ALB Central government debt, total (% of … GC.DOD.TOTL.… 75.69848824949… ## 3 Algeria DZA Central government debt, total (% of … GC.DOD.TOTL.… .. ## 4 American Samoa ASM Central government debt, total (% of … GC.DOD.TOTL.… .. ## 5 Andorra AND Central government debt, total (% of … GC.DOD.TOTL.… .. ## 6 Angola AGO Central government debt, total (% of … GC.DOD.TOTL.… .. ## 7 Antigua and Barbuda ATG Central government debt, total (% of … GC.DOD.TOTL.… .. ## 8 Argentina ARG Central government debt, total (% of … GC.DOD.TOTL.… .. ## 9 Armenia ARM Central government debt, total (% of … GC.DOD.TOTL.… 50.02842068637… ## 10 Aruba ABW Central government debt, total (% of … GC.DOD.TOTL.… .. ## # ℹ 261 more rows ## ## [[2]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Foreign direct investment, net inflow… BX.KLT.DINV.… 0.124495985791… ## 2 Albania ALB Foreign direct investment, net inflow… BX.KLT.DINV.… 7.797920483865… ## 3 Algeria DZA Foreign direct investment, net inflow… BX.KLT.DINV.… 0.804144058246… ## 4 American Samoa ASM Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 5 Andorra AND Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 6 Angola AGO Foreign direct investment, net inflow… BX.KLT.DINV.… -5.78081314444… ## 7 Antigua and Barbuda ATG Foreign direct investment, net inflow… BX.KLT.DINV.… 7.433324076307… ## 8 Argentina ARG Foreign direct investment, net inflow… BX.KLT.DINV.… 1.485006875706… ## 9 Armenia ARM Foreign direct investment, net inflow… BX.KLT.DINV.… 0.736361516844… ## 10 Aruba ABW Foreign direct investment, net inflow… BX.KLT.DINV.… -2.21528256776… ## # ℹ 261 more rows ## ## [[3]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Trade (% of GDP) NE.TRD.GNFS.ZS .. ## 2 Albania ALB Trade (% of GDP) NE.TRD.GNFS.ZS 76.2791946495763 ## 3 Algeria DZA Trade (% of GDP) NE.TRD.GNFS.ZS 51.8097384415762 ## 4 American Samoa ASM Trade (% of GDP) NE.TRD.GNFS.ZS 156.568778979907 ## 5 Andorra AND Trade (% of GDP) NE.TRD.GNFS.ZS .. ## 6 Angola AGO Trade (% of GDP) NE.TRD.GNFS.ZS 57.8295381183036 ## 7 Antigua and Barbuda ATG Trade (% of GDP) NE.TRD.GNFS.ZS 137.625175755884 ## 8 Argentina ARG Trade (% of GDP) NE.TRD.GNFS.ZS 32.6306150458499 ## 9 Armenia ARM Trade (% of GDP) NE.TRD.GNFS.ZS 96.1141541288708 ## 10 Aruba ABW Trade (% of GDP) NE.TRD.GNFS.ZS 145.343572735289 ## # ℹ 261 more rows ## ## [[4]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Urban population (% of total populati… SP.URB.TOTL.… 25.754 ## 2 Albania ALB Urban population (% of total populati… SP.URB.TOTL.… 61.229 ## 3 Algeria DZA Urban population (% of total populati… SP.URB.TOTL.… 73.189 ## 4 American Samoa ASM Urban population (% of total populati… SP.URB.TOTL.… 87.147 ## 5 Andorra AND Urban population (% of total populati… SP.URB.TOTL.… 87.984 ## 6 Angola AGO Urban population (% of total populati… SP.URB.TOTL.… 66.177 ## 7 Antigua and Barbuda ATG Urban population (% of total populati… SP.URB.TOTL.… 24.506 ## 8 Argentina ARG Urban population (% of total populati… SP.URB.TOTL.… 91.991 ## 9 Armenia ARM Urban population (% of total populati… SP.URB.TOTL.… 63.219 ## 10 Aruba ABW Urban population (% of total populati… SP.URB.TOTL.… 43.546 ## # ℹ 261 more rows We will work with the separate data frames in wb_file_list later in the tutorial. 8.3 Reading in a dataset from cloud storage At this point, we have all of the data we need for subsequent sections loaded in our R environment. However, before proceeding, it’s worth noting some additional methods of reading in data into R. If you store your data on the Cloud using a standard storage service such as Dropbox, you can simply extract the URL to the data from your service provider, and pass it as an argument to a data transfer function in R such as read_csv(): # Reads in PT dataset from Dropbox and assigns it to a new object named &quot;pt_cloud&quot; pt_cloud&lt;-read_csv(&quot;https://www.dropbox.com/scl/fi/cow7hk7zsdp46tkzrebxf/persson_tabellini_workshop.csv?rlkey=3dx0dul8uv0c4gpy41ucxwlyo&amp;dl=1&quot;) ## Rows: 85 Columns: 75 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (2): country, continent ## dbl (73): oecd, pind, pindo, ctrycd, col_uk, t_indep, col_uka, col_espa, col_otha, legor_uk, legor_so,... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. The code above reads in the Persson-Tabellini dataset that is stored on a Dropbox account straight into R using its URL as an argument, and assigns it to a new object named pt_cloud. If you view pt_cloud in the data viewer, you’ll notice that the dataset is exactly the same as the one assigned to the pt object. 8.4 Reading in data from an R package 8.5 Reading in data from a website "],["numeric-data-summarizing-processing-and-wrangling-tasks.html", "9 Numeric Data Summarizing, Processing and Wrangling Tasks 9.1 Summary Statistics 9.2 Basic Data Cleaning and Preparation Tasks", " 9 Numeric Data Summarizing, Processing and Wrangling Tasks In this section, we will survey some useful functions (primarily from the dplyr package) for wrangling and processing numeric data. We will demonstrate these functions using the Persson-Tabellini dataset on political-economic data (pt). First, we’ll make a copy of the pt object, by assigning it to a new object named pt_copy. We’ll use pt_copy when exploring the dataset, which ensures that we do not make inadvertent changes to our original pt data frame, and can always refer back to it when needed. Keeping a “clean” version of the data, and carrying out analysis tasks on a copy of this dataset, is good data management practice. # Make a copy of the dataset so we don&#39;t alter the original dataset; then, view # the copied dataset pt_copy&lt;-pt We can go ahead and print the contents of pt_copy, which, at this point, is identical to pt: # Print contents of &quot;pt_copy&quot; pt_copy ## # A tibble: 85 × 75 ## oecd country pind pindo ctrycd col_uk t_indep col_uka col_espa col_otha legor_uk legor_so legor_fr ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 Argentina 0 0 213 0 183 0 0.268 0 0 0 1 ## 2 1 Australia 1 1 193 1 98 0.608 0 0 1 0 0 ## 3 1 Austria 0 0 122 0 250 0 0 0 0 0 0 ## 4 0 Bahamas 1 1 313 1 26 0.896 0 0 1 0 0 ## 5 0 Bangladesh 1 1 513 0 28 0 0 0.888 1 0 0 ## 6 0 Barbados 1 1 316 1 33 0.868 0 0 1 0 0 ## 7 0 Belarus 1 1 913 0 8 0 0 0.968 0 1 0 ## 8 1 Belgium 0 0 124 0 169 0 0 0.324 0 0 1 ## 9 0 Belize 1 1 339 1 18 0.928 0 0 1 0 0 ## 10 0 Bolivia 0.116 0.116 218 0 174 0 0.304 0 0 0 1 ## # ℹ 75 more rows ## # ℹ 62 more variables: legor_ge &lt;dbl&gt;, legor_sc &lt;dbl&gt;, prot80 &lt;dbl&gt;, catho80 &lt;dbl&gt;, confu &lt;dbl&gt;, ## # avelf &lt;dbl&gt;, govef &lt;dbl&gt;, graft &lt;dbl&gt;, logyl &lt;dbl&gt;, loga &lt;dbl&gt;, yrsopen &lt;dbl&gt;, gadp &lt;dbl&gt;, ## # engfrac &lt;dbl&gt;, eurfrac &lt;dbl&gt;, frankrom &lt;dbl&gt;, latitude &lt;dbl&gt;, gastil &lt;dbl&gt;, cgexp &lt;dbl&gt;, cgrev &lt;dbl&gt;, ## # ssw &lt;dbl&gt;, rgdph &lt;dbl&gt;, trade &lt;dbl&gt;, prop1564 &lt;dbl&gt;, prop65 &lt;dbl&gt;, federal &lt;dbl&gt;, eduger &lt;dbl&gt;, ## # spropn &lt;dbl&gt;, yearele &lt;dbl&gt;, yearreg &lt;dbl&gt;, seats &lt;dbl&gt;, maj &lt;dbl&gt;, pres &lt;dbl&gt;, lyp &lt;dbl&gt;, ## # semi &lt;dbl&gt;, majpar &lt;dbl&gt;, majpres &lt;dbl&gt;, propres &lt;dbl&gt;, dem_age &lt;dbl&gt;, lat01 &lt;dbl&gt;, age &lt;dbl&gt;, … We can also view it in the data viewer: # Views &quot;pt_copy&quot; in data frame View(pt_copy) 9.1 Summary Statistics Once you have a dataset loaded into R, one of the first things you’ll want to do is likely to generate a table of summary statistics. A quick way to do that is to use the describe() function from the psych package. Below, we’ll generate summary statistics for the pt_copy dataset by passing it to the describe() function, and assign the table of summary statistics to a new object named pt_copy_summarystats1. We’ll then view it in the data viewer: # Generate summary statistics for &quot;pt_copy&quot; and assign to new object named &quot;pt_copy_summarystats1&quot; pt_copy_summarystats1&lt;-describe(pt_copy) # View contents of &quot;pt_copy_summarystats1&quot; in data viewer View(pt_copy_summarystats1) While having a simple table of summary statistics is often a useful starting point, it is often useful to generate group-level summary statistics, where summary statistics are presented for different subgroups in the dataset. One way to generate group summary statistics is to use the describeBy() function (also from the psych package), where the first argument is the data frame you would like to generate group-level summary statistics for, and the second argument is the column that contains the relevant groups. Below, we generate summary statistics for pt_copy parsed out by the different continents in the “continent” column. The expression pt_copy$continent indicates that the groups with respect to which we want to calcualte the summary statistics is in the “continent” column of the pt_copy data frame. More generally, we can explicitly refer to columns in an R data frame using this dollar-sign notation, where the expression before the dollar sign refers to the data frame object, and the expression after refers to the name of the column. The describeBy() function will produce a list that contains summary statistics for different groups as list elements. Below, we’ll assign the list of group summary statistics to a new object named summary_stats_by_continent: # Creates summary statistics for each continent grouping, and puts results in list named &quot;summary_stats_by_continent&quot; summary_stats_by_continent&lt;-describeBy(pt_copy, pt_copy$continent) Now, let’s say we want to extract the summary statistics for Africa, one of the continent categories in the “continent” column. We can do so using the double-bracket notation we discussed above: # Accessing continent-level summary statistics for africa from the &quot;summary_stats_by_continent&quot; list summary_stats_by_continent[[&quot;africa&quot;]] ## vars n mean sd median trimmed mad min max range skew kurtosis se ## oecd 1 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## country 2 11 53.36 24.45 49.00 54.56 28.17 11.00 85.00 74.00 -0.17 -1.41 7.37 ## pind 3 11 0.77 0.42 1.00 0.83 0.00 0.00 1.00 1.00 -1.06 -0.79 0.13 ## pindo 4 11 0.77 0.42 1.00 0.83 0.00 0.00 1.00 1.00 -1.06 -0.79 0.13 ## ctrycd 5 11 647.55 154.90 684.00 685.56 56.34 199.00 754.00 555.00 -2.13 3.44 46.70 ## col_uk 6 11 0.82 0.40 1.00 0.89 0.00 0.00 1.00 1.00 -1.43 0.08 0.12 ## t_indep 7 11 36.64 19.77 35.00 33.89 5.93 9.00 89.00 80.00 1.38 1.88 5.96 ## col_uka 8 11 0.69 0.35 0.86 0.74 0.02 0.00 0.92 0.92 -1.31 -0.14 0.10 ## col_espa 9 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## col_otha 10 11 0.15 0.33 0.00 0.07 0.00 0.00 0.96 0.96 1.58 0.79 0.10 ## legor_uk 11 11 0.82 0.40 1.00 0.89 0.00 0.00 1.00 1.00 -1.43 0.08 0.12 ## legor_so 12 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## legor_fr 13 11 0.18 0.40 0.00 0.11 0.00 0.00 1.00 1.00 1.43 0.08 0.12 ## legor_ge 14 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## legor_sc 15 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## prot80 16 11 22.17 20.23 25.80 19.96 19.57 0.10 64.20 64.10 0.46 -0.80 6.10 ## catho80 17 11 19.46 13.67 18.70 18.07 13.20 1.90 49.60 47.70 0.71 -0.39 4.12 ## confu 18 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## avelf 19 11 0.71 0.14 0.73 0.73 0.15 0.38 0.84 0.46 -1.15 0.44 0.04 ## govef 20 11 5.37 0.82 5.02 5.25 0.68 4.56 7.26 2.70 0.97 -0.17 0.25 ## graft 21 11 5.11 0.77 5.39 5.12 0.80 3.93 6.23 2.30 -0.17 -1.62 0.23 ## logyl 22 11 7.93 0.78 7.75 7.90 0.53 6.95 9.13 2.18 0.42 -1.43 0.23 ## loga 23 11 7.38 0.66 7.33 7.37 0.55 6.28 8.58 2.29 0.03 -0.91 0.20 ## yrsopen 24 11 0.21 0.29 0.16 0.15 0.18 0.00 1.00 1.00 1.72 2.15 0.09 ## gadp 25 11 0.55 0.12 0.54 0.55 0.12 0.37 0.74 0.37 0.28 -1.38 0.04 ## engfrac 26 11 0.02 0.04 0.00 0.02 0.00 0.00 0.09 0.09 0.95 -1.09 0.01 ## eurfrac 27 11 0.07 0.17 0.00 0.03 0.00 0.00 0.57 0.57 2.24 3.76 0.05 ## frankrom 28 11 2.90 0.51 2.94 2.86 0.56 2.19 3.95 1.77 0.54 -0.69 0.15 ## latitude 29 11 -9.14 15.17 -15.81 -9.58 8.49 -29.13 14.77 43.90 0.44 -1.52 4.57 ## gastil 30 11 3.59 1.16 4.00 3.66 1.32 1.61 4.89 3.28 -0.48 -1.45 0.35 ## cgexp 31 10 27.00 7.63 25.50 27.10 8.58 14.65 38.57 23.92 0.06 -1.30 2.41 ## cgrev 32 9 26.15 10.36 23.81 26.15 6.14 17.24 50.85 33.61 1.40 0.71 3.45 ## ssw 33 6 1.67 1.46 0.94 1.67 0.58 0.44 3.80 3.36 0.52 -1.87 0.60 ## rgdph 34 11 1899.87 1832.60 1116.28 1522.39 738.30 530.22 6666.77 6136.54 1.50 1.28 552.55 ## trade 35 11 77.34 32.13 69.17 76.87 27.13 30.83 128.12 97.29 0.31 -1.40 9.69 ## prop1564 36 11 54.23 4.91 53.23 53.51 2.96 49.05 65.95 16.90 1.19 0.34 1.48 ## prop65 37 11 3.28 1.16 2.80 3.06 0.65 2.34 6.26 3.92 1.47 1.16 0.35 ## federal 38 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## eduger 39 11 73.95 23.54 73.55 73.64 25.47 40.05 110.67 70.62 0.08 -1.50 7.10 ## spropn 40 10 0.27 0.42 0.00 0.21 0.00 0.00 1.00 1.00 0.92 -1.07 0.13 ## yearele 41 8 1982.50 13.48 1990.50 1982.50 5.19 1965.00 1994.00 29.00 -0.41 -2.00 4.77 ## yearreg 42 8 1982.50 13.48 1990.50 1982.50 5.19 1965.00 1994.00 29.00 -0.41 -2.00 4.77 ## seats 43 11 151.20 109.96 122.22 136.21 86.65 37.33 400.00 362.67 0.92 -0.20 33.16 ## maj 44 11 0.73 0.47 1.00 0.78 0.00 0.00 1.00 1.00 -0.88 -1.31 0.14 ## pres 45 11 0.64 0.50 1.00 0.67 0.00 0.00 1.00 1.00 -0.49 -1.91 0.15 ## lyp 46 11 7.22 0.81 7.02 7.15 0.88 6.27 8.80 2.53 0.53 -1.18 0.25 ## semi 47 11 0.18 0.40 0.00 0.11 0.00 0.00 1.00 1.00 1.43 0.08 0.12 ## majpar 48 11 0.18 0.40 0.00 0.11 0.00 0.00 1.00 1.00 1.43 0.08 0.12 ## majpres 49 11 0.55 0.52 1.00 0.56 0.00 0.00 1.00 1.00 -0.16 -2.15 0.16 ## propres 50 11 0.09 0.30 0.00 0.00 0.00 0.00 1.00 1.00 2.47 4.52 0.09 ## dem_age 51 11 1975.82 24.77 1989.00 1981.11 7.41 1910.00 1994.00 84.00 -1.57 1.64 7.47 ## lat01 52 11 0.17 0.08 0.18 0.17 0.05 0.00 0.32 0.32 -0.28 -0.38 0.03 ## age 53 11 0.12 0.12 0.05 0.09 0.04 0.03 0.45 0.42 1.57 1.64 0.04 ## polityIV 54 11 2.34 5.56 0.22 2.42 6.75 -6.00 10.00 16.00 0.07 -1.63 1.68 ## spl 55 8 -1.55 4.52 -1.54 -1.55 1.91 -6.77 8.23 15.00 0.98 0.05 1.60 ## cpi9500 56 9 5.70 1.15 5.90 5.70 1.14 3.93 7.55 3.61 0.01 -1.45 0.38 ## du_60ctry 57 11 0.27 0.47 0.00 0.22 0.00 0.00 1.00 1.00 0.88 -1.31 0.14 ## magn 58 11 0.71 0.41 1.00 0.75 0.00 0.02 1.00 0.98 -0.58 -1.70 0.12 ## sdm 59 9 0.71 0.45 1.00 0.71 0.00 0.03 1.00 0.97 -0.67 -1.63 0.15 ## oecd.x 60 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## mining_gdp 61 10 8.43 11.70 4.10 5.89 5.71 0.02 37.20 37.18 1.39 0.79 3.70 ## gini_8090 62 9 50.25 9.95 54.00 50.25 11.86 35.36 62.30 26.94 -0.19 -1.71 3.32 ## con2150 63 11 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 NaN NaN 0.00 ## con5180 64 11 0.27 0.47 0.00 0.22 0.00 0.00 1.00 1.00 0.88 -1.31 0.14 ## con81 65 11 0.73 0.47 1.00 0.78 0.00 0.00 1.00 1.00 -0.88 -1.31 0.14 ## list 66 11 49.83 119.87 0.00 16.46 0.00 0.00 400.00 400.00 2.22 3.64 36.14 ## maj_bad 67 11 2.73 2.05 3.83 2.80 1.56 0.00 4.89 4.89 -0.32 -1.81 0.62 ## maj_gin 68 9 37.31 22.84 41.35 37.31 18.75 0.00 62.00 62.00 -0.71 -1.17 7.61 ## maj_old 69 11 0.06 0.07 0.04 0.06 0.06 0.00 0.17 0.17 0.69 -1.39 0.02 ## pres_bad 70 11 2.63 2.18 3.83 2.67 1.56 0.00 4.89 4.89 -0.30 -1.92 0.66 ## pres_gin 71 9 26.72 26.59 35.36 26.72 39.50 0.00 62.00 62.00 0.04 -1.97 8.86 ## pres_old 72 11 0.04 0.05 0.03 0.03 0.04 0.00 0.17 0.17 1.66 2.10 0.02 ## propar 73 11 0.18 0.40 0.00 0.11 0.00 0.00 1.00 1.00 1.43 0.08 0.12 ## lpop 74 3 13.99 0.15 13.92 13.99 0.05 13.88 14.17 0.28 0.36 -2.33 0.09 ## continent 75 11 1.00 0.00 1.00 1.00 0.00 1.00 1.00 0.00 NaN NaN 0.00 Recall that we can assign list elements that we extract from a list to their own object, which allows us to conveniently retrieve it whenever it is needed. Below, we’ll assign the summary statistics for Africa to a new object named africa_summary: # Group-level summary statistics can be assigned to their own object for easy retrieval africa_summary&lt;-summary_stats_by_continent[[&quot;africa&quot;]] Another convenient way to retrieve group-level summary statistics is through the group_by() function in the dplyr package. First, we’ll run the code below, and assign it to a new object named trade_age_by_continent: # Generate a table that displays summary statistics for trade at the continent level and assign to object named &quot;trade_age_by_continent&quot; trade_age_by_continent&lt;-pt_copy %&gt;% group_by(continent) %&gt;% summarise(meanTrade=mean(trade),sdTrade=sd(trade), meanAge=mean(age), sdAge=sd(age), n=n()) Now, let’s print the contents of trade_age_by_continent: # prints contents of &quot;trade_age_by_continent&quot; trade_age_by_continent ## # A tibble: 4 × 6 ## continent meanTrade sdTrade meanAge sdAge n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 africa 77.3 32.1 0.121 0.124 11 ## 2 asiae 97.8 84.6 0.110 0.0846 13 ## 3 laam 68.6 32.8 0.139 0.153 23 ## 4 other 78.8 40.7 0.309 0.263 38 Let’s now unpack the code that created this table. We started with the pt_copy data frame, and then used group_by(continent) to declare that subsequent calculations should be performed at the continent-level; then, within the summarise() function, we defined the column names we wanted to use in the group-level summary table, and how those variables are to be calculated. For example, meanTrade=mean(trade) indicates that we want the first column to be named “meanTrade”, which is to be calculated by taking the mean of the “trade” variable for each continent grouping. After that, sdTrade=sd(trade) indicates that we want the second column to be named “sdTrade”, which is to be calculated by taking the standard deviation of the “trade” variable for each continent grouping. And so on. Note that n=n() indicates that we want the final column, named “n”, to provide information about the number of observations in each continent-level grouping. You might have noticed a mysterious symbol in the above code that comes immediately after pt_copy, and immediately after group_by(continent). This symbol is known as a “pipe” (%&gt;%). The pipe operator effectively takes the contents to its left, and then uses these contents as an input to the code on its right. Above, the pipe takes the contents of pt_copy on its left, and then feeds this data into the group_by() function on the right; then, after grouping the data by continent, it feeds this grouped data on its left into the summarise() function on its right. We will use the pipe operator throughout the lesson to chain together functions in this manner. Finally, in addition to calculating summary statistics and group-level summary statistics, another useful way to explore your data is to generate simple crosstabs that show the breakdown of one variable with respect to the other. The code below uses the tabyl() function from the janitor package to compute a crosstab between the “federal” variable (i.e. this variable takes on the value of 1 if a country has a federal structure of government, and 0 if it’s a unitary government) and the “continent” variable; it assigns the crosstab to a new object named crosstab_federal_continent: # Creates cross-tab showing the breakdown of federal/non federal across continents crosstab_federal_continent&lt;-pt_copy %&gt;% tabyl(federal, continent) Let’s print the contents of crosstab_federal_continent: # prints contents of &quot;crosstab_federal_continent&quot; crosstab_federal_continent ## federal africa asiae laam other ## 0 11 11 19 29 ## 1 0 2 4 7 ## NA 0 0 0 2 This tells us, for instance, that among Latin American countries, 19 had a unitary government, and 4 had federal structure of government. 9.2 Basic Data Cleaning and Preparation Tasks After getting a sense of your data by computing some summary statistics and running some crosstabs, you’ll often have a sense of how you would like to clean or transform your data for analysis. This subsection briefly describes some functions that are useful for these basic data-preparation tasks. 9.2.1 Rearranging Columns We can manipulate the order of the columns in a dataset using the relocate function. For example, the code below uses the relocate() function to shift the “country” column to the front of the dataset, and then assigns this change back to pt_copy to update the object: # bring the &quot;country&quot; column to the front of the dataset pt_copy&lt;-pt_copy %&gt;% relocate(country) You can confirm that the change has been implemented by viewing pt_copy in the data viewer: # Views &quot;pt_copy&quot; in data viewer View(pt_copy) You can specify more than one argument to the relocate function. For example, in the code below, passing the “country”, “list”, “trade”, and “oecd” variables/columns to the relocate() function will make “country” the first column, “list” the second column, “trade” the third column, and so on. # bring the &quot;country&quot;, &quot;list&quot;, &quot;trade&quot;, &quot;oecd&quot; columns to the front of the dataset pt_copy&lt;-pt_copy %&gt;% relocate(country, list, trade, oecd) # Views updated &quot;pt_copy&quot; data frame in data viewer View(pt_copy) 9.2.2 Renaming Variables In order to rename variables, we can use the rename() function, as below. The code below renames the existing “list” variable to “party_list”, which is more descriptive, and assigns the change back to the pt_copy object. ## Renaming a variable (renames &quot;list&quot; to &quot;party_list&quot;) pt_copy&lt;-pt_copy %&gt;% rename(party_list=list) Check the pt_copy data frame in the viewer to ensure that the change has been made. 9.2.3 Sorting a dataset in ascending or descending order with respect to a variable It is often useful to sort a data frame in ascending or descending order with respect to a given variable. The code below sorts the pt_copy data frame in ascending order with respect to the “trade” variable using the arrange() function: # sorting in ascending (low to high) order with respect to the &quot;trade&quot; variable pt_copy&lt;-pt_copy %&gt;% arrange(trade) If, instead, you want to sort the dataset in descending order with respect to the “trade” variable, pass the name of the variable to the desc() function within the arrange() function, as below: # sorting in descending (high to low) order with respect to the &quot;trade&quot; variable pt_copy&lt;-pt_copy %&gt;% arrange(desc(trade)) 9.2.4 Creating new variables based on existing variables Depending on your research question and empirical strategy, it is often useful or necessary to create new variables in your dataset, based on existing variables. To do so, we can use dplyr’s mutate() function. The code below, for example, uses the mutate() function to create a new variable, named “non_catholic_80”, that is computed by subtracting the existing “catho80” variable from 100; for convenience, the “country”, “catho80”, and newly created “non_catholic_80” variables are all moved to the front of the dataset using the relocate() function: # Create new variable named &quot;non_catholic_80&quot; that is calculated by substracting the Catholic share of the population in 1980 (&quot;catho80&quot;) from 100 and relocates &quot;country&quot;, &quot;catho80&quot;, and the newly created &quot;non_catholic_80&quot; to the front of the dataset pt_copy&lt;-pt_copy %&gt;% mutate(non_catholic_80=100-catho80) %&gt;% relocate(country, catho80, non_catholic_80) You can view the updated pt_copy data frame to confirm that the new variable has been created: # views updated &quot;pt_copy&quot; data frame in R Studio data viewer View(pt_copy) 9.2.5 Selecting or Deleting Variables Sometimes, you will have a dataset with many variables, and to make things more tractable, you’ll want to select only the variables that are relevant to your analysis. You can explicitly select desired variables using the select() function from dplyr. The code below selects the “country”, “cgexp”, “cgrev”, “trade”, and “federal” columns from pt_copy, and then assigns this selection to a new object named pt_copy_selection: # Selects &quot;country&quot;, &quot;cgexp&quot;, &quot;cgrev&quot;, and &quot;trade&quot; variables from the &quot;pt_copy&quot; dataset and assigns the selection to a new object named &quot;pt_copy_selection&quot; pt_copy_selection&lt;-pt_copy %&gt;% select(country, cgexp, cgrev, trade, federal) When you view the pt_copy_selection object in the data viewer, you’ll see that we now have a new data frame that consists only of these variables: # views &quot;pt_copy_selection&quot; in data viewer View(pt_copy_selection) Instead of selecting columns to keep, it may sometimes by easier to directly delete columns. For example, the code below deletes the “federal” variable from pt_copy_selection by passing it to the select() column with a “-” in front of it. # deletes &quot;federal&quot; variable from &quot;pt_copy_selection&quot; pt_copy_selection %&gt;% select(-federal) ## # A tibble: 85 × 4 ## country cgexp cgrev trade ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Singapore 18.5 34.7 343. ## 2 Malta 41.0 35.0 190. ## 3 Luxembourg 40.2 45.5 189. ## 4 Malaysia 24.5 26.8 176. ## 5 Estonia 30.0 31.1 154. ## 6 Belgium 47.9 43.7 132. ## 7 Ireland 38.1 34.8 129. ## 8 Mauritius 22.5 21.6 128. ## 9 St. Vincent&amp;G 34.8 28.7 123. ## 10 Jamaica NA NA 122. ## # ℹ 75 more rows If you want to delete multiple columns, simply specify the columns in a vector, preceded by a minus sign, that is passed to the select() function. The code below, for instance, takes the existing pt_copy_selection data frame, deletes the “federal” and “trade” columns, and assigns the result to a new object named pt_copy_selection_modified: # deletes &quot;federal&quot; and &quot;trade&quot; from &quot;pt_copy_selection&quot; and assigns it to new object named &quot;pt_copy_selection_modified&quot; pt_copy_selection_modified&lt;-pt_copy_selection %&gt;% select(-c(federal, trade)) Check the pt_copy_selection_modified data frame in the data viewer to confirm these changes: # views &quot;pt_copy_selection_modified&quot; in data viewer pt_copy_selection_modified ## # A tibble: 85 × 3 ## country cgexp cgrev ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Singapore 18.5 34.7 ## 2 Malta 41.0 35.0 ## 3 Luxembourg 40.2 45.5 ## 4 Malaysia 24.5 26.8 ## 5 Estonia 30.0 31.1 ## 6 Belgium 47.9 43.7 ## 7 Ireland 38.1 34.8 ## 8 Mauritius 22.5 21.6 ## 9 St. Vincent&amp;G 34.8 28.7 ## 10 Jamaica NA NA ## # ℹ 75 more rows 9.2.6 Recoding Variables “Recoding” a variable refers to the process of taking an existing variable, and generating new variable(s) that represent the information from that original variable in a new way. Below, we’ll consider some common recoding operations. Creating Dummy Variables from Continuous Numeric Variables You may sometimes have a continuous numeric variable, but want to create a new dummy variable (a variable that takes on the value of 1 if a given condition is met, and 0 otherwise) based on that numeric variable. For example, let’s say we want to create a new variable, named “trade_open” that takes on the value of 1 if the trade variable is greater than or equal to 77, and 0 otherwise. We can generate this new dummy variable using the mutate() function; within the mutate() function below, we specify that we want to create a new variable named “trade_open”; the ifelse() function specifies the desired condition (trade&gt;=77), followed by the value the new “trade_open” variable is to take if the condition is met (1), and the value the new “trade_open” variable is to take if the condition is not met (0). In other words, we can translate ifelse(trade&gt;=77, 1, 0) to “if trade&gt;=77, set the ‘trade_open’ variable to 1, otherwise set it to 0.” We’ll assign the data frame with the new “trade_open” variable back to “pt_copy”: # Creates a new dummy variable based on the existing &quot;trade&quot; variable named &quot;trade_open&quot; (which takes on a value of &quot;1&quot; if &quot;trade&quot; is greater than or equal to 77, and 0 otherwise) and then moves the newly created variable to the front of the dataset along with &quot;country&quot; and &quot;trade&quot;; all changes are assigned to &quot;pt_copy&quot;, thereby overwriting the existing version of &quot;pt_copy&quot; pt_copy&lt;-pt_copy %&gt;% mutate(trade_open=ifelse(trade&gt;=77, 1, 0)) %&gt;% relocate(country, trade_open, trade) View the data frame to ensure that the new variable “trade_open”, recoded based on “trade”, has been created: Creating categorical variables from continuous numeric variables Sometimes, you will want to create a variable that contains categories or classifications that derive from numeric thresholds of an existing variable. For instance, let’s say we want to take the existing “trade” variable, and define a new variable named “trade_level”, which is set to “Low Trade” when the “trade” variable is greater than 15 and less than 50; “Intermediate_Trade” when the “trade” variable is greater than or equal to 50 and less than 100; and “High_Trade” when the “trade” variable is greater than or equal to 100. The code below creates this new “trade_level” variable using the mutate() function, and the case_when() function that maps the conditions onto the desired variable values for “trade_level” using the following syntax: # Creates a new variable in the &quot;pt_copy&quot; dataset named &quot;trade_level&quot; (that is coded as &quot;Low Trade&quot; when the &quot;trade&quot; variable is greater than 15 and less than 50, coded as &quot;Intermediate Trade&quot; when &quot;trade&quot; is greater than or equal to 50 and less than 100, and coded as &quot;High TradE&quot; when &quot;trade&quot; is greater than or equal to 100), and then reorders the dataset such that &quot;country&quot;, &quot;trade_level&quot;, and &quot;trade&quot; are the first three variables in the dataset pt_copy&lt;-pt_copy %&gt;% mutate(trade_level=case_when(trade&gt;15 &amp; trade&lt;50~&quot;Low_Trade&quot;, trade&gt;=50 &amp; trade&lt;100~&quot;Intermediate_Trade&quot;, trade&gt;=100~&quot;High_Trade&quot;)) %&gt;% relocate(country, trade_level, trade) Check to see that the new “trade_level” variable has indeed been created in pt_copy according to the specifications above: # views updated &quot;pt_copy&quot; data frame in data viewer View(pt_copy) Creating dummmy variables from categorical variables Sometimes, you may have a categorical variable in a dataset, and want to create dummy variables based on those categories. For example, consider the “trade_level” variable we created above. Let’s say we want to use the “trade_level” column to create dummy variables for each of the categories in that column. We can do so with the fastDummies package, which can quickly generate dummy variables for the categories in a categorical variable using the dummy_cols() function. Below, we simply take the existing pt_copy dataset, and pass the name of the categorical variable out of which we want to create the dummies (“trade_level”) to the dummy_cols() function: # Creates dummy variables from &quot;trade_level&quot; column, and relocates the new dummies to the front of the dataset pt_copy&lt;-pt_copy %&gt;% dummy_cols(&quot;trade_level&quot;) %&gt;% relocate(country, trade_level, trade_level_High_Trade, trade_level_Intermediate_Trade, trade_level_Low_Trade) Let’s now view the updated pt_copy data frame, with the newly created dummy variables: # views updated &quot;pt_copy&quot; in data viewer View(pt_copy) You’ll notice that there are now dummy variables corresponding to each of the categories in the categorical “trade_level” variable; for example, the “trade_level_High_Trade” dummy variable takes on the value of 1 for all observations where the “trade_level” variable is “High_Trade” and 0 otherwise; the “trade_level_Intermediate_Trade” dummy variable takes on the value of 1 for all observations where the “trade_level” variable is “Intermediate_Trade” and 0 otherwise; and so on. 9.2.7 Subsetting Variables You will often want to subset, or “filter” your datasets to extract observations that meet specified criteria. The dplyr packages allows you to carry out these subsetting operations with a function called filter(), which takes various logical conditions as arguments. Let’s say, for example, that we want to extract all of the OECD country observations from the pt_copy dataset. The “oecd” variable in pt_copy is equal to 1, for all OECD countries, and 0 for non-OECD countries. By passing the condition oecd==1 to the filter() function, we can extract all OECD observations. We’ll assign this data subset to a new object named oecd_countries, and view it in the data viewer: # Extracts OECD observations in &quot;pt_copy&quot; and assigns to object named &quot;oecd_countries&quot; oecd_countries&lt;-pt_copy %&gt;% filter(oecd==1) %&gt;% relocate(country, oecd) # views &quot;oecd_countries&quot; in data viewer View(oecd_countries) Let’s take another example. Let’s use the filter() function to extract all observations for which the “cgrev” (central government revenue as a share of GDP) exceeds 40. We’ll assign the observations that satisfy this condition to a new object named high_revenues: # Extracts observations for which cgrev (central government revenue as % of gdp)&gt;40, and assigns to object named &quot;high_revenues&quot; high_revenues&lt;-pt_copy %&gt;% filter(cgrev&gt;40) %&gt;% relocate(country, cgrev) # Views &quot;high_revenues&quot; in data viewer high_revenues ## # A tibble: 10 × 81 ## country cgrev trade_level trade_level_High_Trade trade_level_Intermed…¹ trade_level_Low_Trade trade ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Luxembourg 45.5 High_Trade 1 0 0 189. ## 2 Belgium 43.7 High_Trade 1 0 0 132. ## 3 Netherlands 47.6 High_Trade 1 0 0 100. ## 4 Botswana 50.8 Intermedia… 0 1 0 87.5 ## 5 Hungary 45.6 Intermedia… 0 1 0 73.7 ## 6 Norway 41.1 Intermedia… 0 1 0 72.2 ## 7 Sweden 40.8 Intermedia… 0 1 0 68.1 ## 8 Poland 40.3 Low_Trade 0 0 1 48.3 ## 9 France 40.9 Low_Trade 0 0 1 44.9 ## 10 Italy 41.2 Low_Trade 0 0 1 44.3 ## # ℹ abbreviated name: ¹​trade_level_Intermediate_Trade ## # ℹ 74 more variables: trade_open &lt;dbl&gt;, catho80 &lt;dbl&gt;, non_catholic_80 &lt;dbl&gt;, party_list &lt;dbl&gt;, ## # oecd &lt;dbl&gt;, pind &lt;dbl&gt;, pindo &lt;dbl&gt;, ctrycd &lt;dbl&gt;, col_uk &lt;dbl&gt;, t_indep &lt;dbl&gt;, col_uka &lt;dbl&gt;, ## # col_espa &lt;dbl&gt;, col_otha &lt;dbl&gt;, legor_uk &lt;dbl&gt;, legor_so &lt;dbl&gt;, legor_fr &lt;dbl&gt;, legor_ge &lt;dbl&gt;, ## # legor_sc &lt;dbl&gt;, prot80 &lt;dbl&gt;, confu &lt;dbl&gt;, avelf &lt;dbl&gt;, govef &lt;dbl&gt;, graft &lt;dbl&gt;, logyl &lt;dbl&gt;, ## # loga &lt;dbl&gt;, yrsopen &lt;dbl&gt;, gadp &lt;dbl&gt;, engfrac &lt;dbl&gt;, eurfrac &lt;dbl&gt;, frankrom &lt;dbl&gt;, latitude &lt;dbl&gt;, ## # gastil &lt;dbl&gt;, cgexp &lt;dbl&gt;, ssw &lt;dbl&gt;, rgdph &lt;dbl&gt;, prop1564 &lt;dbl&gt;, prop65 &lt;dbl&gt;, federal &lt;dbl&gt;, … Let’s try another example. Let’s subset observations from pt_copy for which the Catholic share of the population in 1980 (“catho80”) is less than or equal to 50, and assign the filtered data to a new object named minority_catholic: # Extracts observations for which the &quot;catho80&quot; variable is less than or equal to 50 minority_catholic&lt;-pt_copy %&gt;% filter(catho80&lt;=50) %&gt;% relocate(country, catho80) # Views &quot;minority_catholic&quot; in the data viewer View(minority_catholic) It is also possible to chain together multiple conditions as arguments to the filter() function. For example, if we want to subset observations from OECD countries that also have a federal political structure, we can use the “&amp;” operator to specify these two conditions; we’ll assign the filtered dataset to a new object named oecd_federal_countries: # Extracts federal OECD countries (where oecd=1 AND federal=1) and assigns to a new object named &quot;oecd_federal_countries&quot; oecd_federal_countries&lt;-pt_copy %&gt;% filter(oecd==1 &amp; federal==1) %&gt;% relocate(country, oecd, federal) # Views &quot;oecd_federal_countries&quot; in data viewer oecd_federal_countries ## # A tibble: 7 × 81 ## country oecd federal trade_level trade_level_High_Trade trade_level_Intermed…¹ trade_level_Low_Trade ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Austria 1 1 Intermedia… 0 1 0 ## 2 Switzerla… 1 1 Intermedia… 0 1 0 ## 3 Canada 1 1 Intermedia… 0 1 0 ## 4 Germany 1 1 Low_Trade 0 0 1 ## 5 Mexico 1 1 Low_Trade 0 0 1 ## 6 Australia 1 1 Low_Trade 0 0 1 ## 7 USA 1 1 Low_Trade 0 0 1 ## # ℹ abbreviated name: ¹​trade_level_Intermediate_Trade ## # ℹ 74 more variables: trade &lt;dbl&gt;, trade_open &lt;dbl&gt;, catho80 &lt;dbl&gt;, non_catholic_80 &lt;dbl&gt;, ## # party_list &lt;dbl&gt;, pind &lt;dbl&gt;, pindo &lt;dbl&gt;, ctrycd &lt;dbl&gt;, col_uk &lt;dbl&gt;, t_indep &lt;dbl&gt;, col_uka &lt;dbl&gt;, ## # col_espa &lt;dbl&gt;, col_otha &lt;dbl&gt;, legor_uk &lt;dbl&gt;, legor_so &lt;dbl&gt;, legor_fr &lt;dbl&gt;, legor_ge &lt;dbl&gt;, ## # legor_sc &lt;dbl&gt;, prot80 &lt;dbl&gt;, confu &lt;dbl&gt;, avelf &lt;dbl&gt;, govef &lt;dbl&gt;, graft &lt;dbl&gt;, logyl &lt;dbl&gt;, ## # loga &lt;dbl&gt;, yrsopen &lt;dbl&gt;, gadp &lt;dbl&gt;, engfrac &lt;dbl&gt;, eurfrac &lt;dbl&gt;, frankrom &lt;dbl&gt;, latitude &lt;dbl&gt;, ## # gastil &lt;dbl&gt;, cgexp &lt;dbl&gt;, cgrev &lt;dbl&gt;, ssw &lt;dbl&gt;, rgdph &lt;dbl&gt;, prop1564 &lt;dbl&gt;, prop65 &lt;dbl&gt;, … We can use a vertical line (|) to specify “or” conditions. For example, the code below subsets observations from countries in Africa OR countries in Asia/Europe, and assigns the subsetted data to a new object named asia_europe_africa: # Extracts observations that are in Africa (&quot;africa&quot;) OR in Asia/Europe (&quot;asiae) and assigns to an object named &quot;asia_europe_africa&quot; asia_europe_africa&lt;-pt_copy %&gt;% filter(continent==&quot;africa&quot;|continent==&quot;asiae&quot;) %&gt;% relocate(continent) # views &quot;asia_europe_africa&quot; in data viewer View(asia_europe_africa) # Prints contents of &quot;asia_europe_africa&quot; asia_europe_africa %&gt;% datatable(extensions=c(&quot;Scroller&quot;, &quot;FixedColumns&quot;), options = list( deferRender = TRUE, scrollY = 350, scrollX = 350, dom = &quot;t&quot;, scroller = TRUE, fixedColumns = list(leftColumns = 3) )) It is also useful to know how to subset datasets to extract observations that do NOT meet a given condition. In particular, the condition “not equal to” is denoted by a “!=”. For example, if we wanted to extract observations from pt_copy where the “continent” variable is NOT equal to “africa”, and assign the result to a new object named pt_copy_sans_africa, we can write the following: # Extracts all non-Africa observations and assigns to object named &quot;pt_copy_sans_africa&quot; pt_copy_sans_africa&lt;-pt_copy %&gt;% filter(continent!=&quot;africa&quot;) %&gt;% relocate(continent) # views pt_copy_sans_africa in the data viewer View(pt_copy_sans_africa) # Prints contents of &quot;pt_copy_sans_africa&quot; pt_copy_sans_africa %&gt;% datatable(extensions=c(&quot;Scroller&quot;, &quot;FixedColumns&quot;), options = list( deferRender = TRUE, scrollY = 350, scrollX = 350, dom = &quot;t&quot;, scroller = TRUE, fixedColumns = list(leftColumns = 3) )) "],["exploratory-visualization.html", "10 Exploratory Visualization 10.1 Bar Charts 10.2 Scatterplots", " 10 Exploratory Visualization R has a number of powerful visualization capabilities, but one of the most frequently used tools for data visualization in R is the ggplot2 package, which is a part of the tidyverse suite. Data visualization using ggplot2 is a vast topic; our goal here is to provide you with some basic intuition for how ggplot visualizations are constructed by developing some basic exploratory visualizations. While our treatment here focuses on bar charts and scatterplots, ggplot offers functions for a much wider variety of visualizations. However, bar charts and scatterplots offer a convenient way to familiarize yourself with basic ggplot syntax. 10.1 Bar Charts Let’s make some simple bar charts for the African countries in pt_copy. Let’s say we want to make a bar chart that displays variation in the “cgexp” variable (central government expenditure as a share of GDP) for African countries. We’ll begin by extracting the Africa observations from pt_copy using the filter() function, and removing any “NA” observations for this variable from the dataset using the drop_na() function: # filters Africa observations pt_africa&lt;-pt_copy %&gt;% filter(continent==&quot;africa&quot;) %&gt;% drop_na(cgexp) Now, let’s make a basic bar chart of the “cgexp” data from pt_africa, and assign it to an object named cgexp_africa: # Creates a bar chart of the &quot;cgexp&quot; variable (central government expenditure as a share of GDP) for the Africa observations and assigns the plot to an object named &quot;cgexp_africa&quot; cgexp_africa&lt;- ggplot(pt_africa)+ geom_col(aes(x=country, y=cgexp))+ labs( title=&quot;Central Govt Expenditure as Pct of GDP for Select African Countries (1990-1998 Average)&quot;, x=&quot;Country Name&quot;, y=&quot;CGEXP&quot;)+ theme(plot.title=element_text(hjust=0.5), axis.text.x = element_text(angle = 90)) Let’s unpack the code above: The expression ggplot(pt_africa) specifies that we want to initialize ggplot, and declares the dataset containing the data we want to map (“pt_africa”) geom_col() indicates that we want to make a bar chart. If you wanted to make a different type of chart, this function would be different. Within the geom_col() function, we indicate our desired aesthetic mapping aes(); an aesthetic mapping indicates how we would like variables in the datasets to be represented on the chosen visualization. Here, the expression x=country, y=cgexp simply indicates that we want countries to be represented on the x-axis of the chart, and the “cgexp” variable to be represented on the y-axis. The arguments to the labs() function (short for “labels”) specify a desired title for the visualization, and x-axis and y-axis labels. The arguments to the theme() function specify a desired position for the plot title, and a desired format for the x-axis labels. Note that ggplot2 functions are chained together with a “+” sign. Let’s see what cgexp_africa looks like: # prints contents of cgexp_africa cgexp_africa This is a nice start, but it may look a bit cleaner if we arrayed the chart in ascending order with respect to the cgexp variable. To do so, we can slightly change our aesthetic mapping to look like this: aes(x=reorder(country, cgexp), y=cgexp)). This indicates that we’d still like the “cgexp” variable on the y-axis, and countries on the x-axis; however, we’d also like to order countries in ascending order with respect to the “cgexp” variable. We’ll assign this modified chart to a new object named cgexp_africa_ascending: # Creates a bar chart of the &quot;cgexp&quot; variable (central government expenditure as a share of GDP) for the Africa observations; countries are on the x axis and arrayed in ascending order with respect to the cgexp variable, which is on the y-axis; plot is assigned to an object named &quot;cgexp_africa_ascending&quot; cgexp_africa_ascending&lt;- ggplot(pt_africa)+ geom_col(aes(x=reorder(country, cgexp), y=cgexp))+ labs( title=&quot;Central Govt Expenditure as Pct of GDP for Select African Countries (1990-1998 Average)&quot;, x=&quot;Country Name&quot;, y=&quot;CGEXP&quot;)+ theme(plot.title=element_text(hjust=0.5), axis.text.x = element_text(angle = 90)) All other apsects of the code are the same as before. Let’s see what the modified chart looks like: # prints &quot;cgexp_africa_ascending&quot; cgexp_africa_ascending If, instead of arrange the countries in asscending order with respect to the “cgexp” variable, we want to arrange them in descending order, we can simply put a “-” before “cgexp” within the aesthetic mapping; we’ll assign the modified chart to a new object named cgexp_africa_descending: # Creates a bar chart of the &quot;cgexp&quot; variable (central government expenditure as a share of GDP) for the Africa observations; countries are on the x axis and arrayed in descending order with respect to the cgexp variable, which is on the y-axis; plot is assigned to an object named &quot;cgexp_africa_descending&quot; cgexp_africa_descending&lt;- ggplot(pt_africa)+ geom_col(aes(x=reorder(country, -cgexp), y=cgexp))+ labs( title=&quot;Central Govt Expenditure as Pct of GDP for Select African Countries (1990-1998 Average)&quot;, x=&quot;Country Name&quot;, y=&quot;CGEXP&quot;)+ theme(plot.title=element_text(hjust=0.5), axis.text.x = element_text(angle = 90)) Let’s see how the cgexp_africa_descending plot now looks: # prints contents of &quot;cgexp_africa_descending&quot; cgexp_africa_descending Sometimes, you may wish to invert the axes of your charts, which you can do using the coord_flip() function. The code below takes the cgexp_africa_ascending chart we created above, inverts the axes using coord_flip(), and assigns the result to a new object named cgexp_africa_ascending_inverted: # creates a sideways bar chart using the &quot;coord_flip&quot; function and assigns it to a new object named &quot;cgexp_africa_ascending_inverted&quot; cgexp_africa_ascending_inverted&lt;-cgexp_africa_ascending+ coord_flip() Let’s see what cgexp_africa_ascending_inverted looks like: # prints &quot;cgexp_africa_ascending_inverted&quot; cgexp_africa_ascending_inverted 10.2 Scatterplots The syntax to make a scatterplot is fairly similar to the syntax used to create a bar chart; the main difference is that instead of using the geom_col() function to indicate that we want a bar chart, we use the geom_point() function to indicate that we want a scatterplot. The code below generates a scatterplot of the “cgexp” variable (on the x axis) and the “trade” variable (on the y-axis) for all observations in the pt_copy dataset, and assigns it to a new object named scatter_cgexp_trade: # Creates scatterplot with &quot;cgexp&quot; variable on x-axis and &quot;trade&quot; variiable on y-axis and assigns to object named &quot;scatter_cgexp_trade&quot; scatter_cgexp_trade&lt;- ggplot(pt_copy)+ geom_point(aes(x=cgexp, y=trade))+ labs(title=&quot;Trade Share of GDP \\nas a function of\\n Central Govt Expenditure (1990-1998 Average) &quot;, x=&quot;Central Government Expenditure (Pct of GDP)&quot;, y=&quot;Overall Trade (Pct of GDP)&quot;)+ theme(plot.title=element_text(hjust=0.5)) Let’s see what scatter_cgexp_trade looks like: # prints contents of &quot;scatter_cgexp_trade&quot; scatter_cgexp_trade ## Warning: Removed 3 rows containing missing values (`geom_point()`). Sometimes, you may wish to distinguish between different groups in a scatterplot. One way to do that is to assign different colors to different groups of interest. For example, if we wanted to distinguish continents in the scatterplot, we could specify color=continent in the aesthetic mapping. The code below does so, and assigns the result to a new object named scatter_cgexp_trade_grouped: # Creates scatterplot with &quot;cgexp&quot; variable on x-axis and &quot;trade&quot; variable on y-axis, and uses different color points for different continents; plot is assigned to object named &quot;scatter_cgexp_trade_grouped&quot; scatter_cgexp_trade_grouped&lt;- ggplot(pt_copy)+ geom_point(aes(x=cgexp, y=trade, color=continent))+ labs(title=&quot;Trade Share of GDP \\nas a function of\\n Central Govt Expenditure (1990-1998 Average) &quot;, x=&quot;Central Government Expenditure (Pct of GDP)&quot;, y=&quot;Overall Trade (Pct of GDP)&quot;)+ theme(plot.title=element_text(hjust=0.5)) Let’s see what scatter_cgexp_trade_grouped looks like: # prints contents of &quot;scatter_cgexp_trade_grouped&quot; scatter_cgexp_trade_grouped ## Warning: Removed 3 rows containing missing values (`geom_point()`). An alternative way of parsing categories is to use facets, which create separate visualizations for each of the different categories in a dataset. Below, for example, we create separate scatterplots for each continent (this is specified by the final line in the code, facet_wrap(~continent, nrow=2)): # Creates continent-level subplots for scatterplot, using facets; assigns plot to new object named &quot;scatter_cgexp_trade_facets&quot; scatter_cgexp_trade_facets&lt;- ggplot(pt_copy) + geom_point(aes(x = cgexp, y = trade)) + facet_wrap(~ continent, nrow = 2) # prints contents of &quot;scatter_cgexp_trade_facets&quot; scatter_cgexp_trade_facets ## Warning: Removed 3 rows containing missing values (`geom_point()`). Finally, it’s important to note that it’s possible to layer different geometries over each other. For example, the code below plots a scatterplot for the pt_copy dataset with the “cgexp” variable on the x axis and the trade variable on the y-axis, but also plots a line of best fit on top of the scatterplot with geom_smooth(aes(x=cgexp, y=trade), method=\"lm\"); we’ll assign the resulting plot to scatter_cgexp_trade_line: # Creates scatterplot with &quot;cgexp&quot; variable on x-axis and &quot;trade&quot; variiable on y-axis, adds line of best fit; plot assigned to object named &quot;scatter_cgexp_trade_line&quot; scatter_cgexp_trade_line&lt;- ggplot(pt_copy)+ geom_point(aes(x=cgexp, y=trade))+ geom_smooth(aes(x=cgexp, y=trade), method=&quot;lm&quot;)+ labs(title=&quot;Trade Share of GDP \\nas a function of\\n Central Govt Expenditure (1990-1998 Average) &quot;, x=&quot;Central Government Expenditure (Pct of GDP)&quot;, y=&quot;Overall Trade (Pct of GDP)&quot;)+ theme(plot.title=element_text(hjust=0.5)) # Prints contents of &quot;scatter_cgexp_trade_line&quot; scatter_cgexp_trade_line ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 3 rows containing non-finite values (`stat_smooth()`). ## Warning: Removed 3 rows containing missing values (`geom_point()`). "],["elementary-data-analysis.html", "11 Elementary Data Analysis 11.1 Computing correlations 11.2 Basic regression analysis 11.3 Working with categorical variables in a regression model 11.4 Working with interaction terms in regression models 11.5 Creating and exporting regression tables", " 11 Elementary Data Analysis 11.1 Computing correlations 11.1.1 Computing correlations between two variables in a dataset # Prints correlation coefficient between &quot;trade&quot; and &quot;cgexp&quot; variables cor.test(pt_copy$trade, pt_copy$cgexp, use=&quot;complete.obs&quot;) ## ## Pearson&#39;s product-moment correlation ## ## data: pt_copy$trade and pt_copy$cgexp ## t = 1.8131, df = 80, p-value = 0.07356 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## -0.01915884 0.39850057 ## sample estimates: ## cor ## 0.1986743 11.1.2 Generating and exporting a correlation matrix # Extracts variables for which we want a correlation matrix desired_variables&lt;-pt_copy %&gt;% select(trade, cgexp, cgrev, catho80) # Creates correlation matrix from &quot;desired_variables&quot; object and assigns to object named &quot;cor_matrix&quot; cor_matrix&lt;-cor(desired_variables, use=&quot;complete.obs&quot;) # prints contents of &quot;cor_matrix&quot; cor_matrix ## trade cgexp cgrev catho80 ## trade 1.00000000 0.1792884 0.3458730 -0.08442666 ## cgexp 0.17928838 1.0000000 0.9094998 -0.07010910 ## cgrev 0.34587298 0.9094998 1.0000000 -0.05923500 ## catho80 -0.08442666 -0.0701091 -0.0592350 1.00000000 # Exports correlation matrix assigned to &quot;cor_matrix&quot; object using stargazer stargazer(cor_matrix, type=&quot;text&quot;, title=&quot;Correlation Matrix&quot;, digits=3, out=&quot;corr_table.html&quot;) ## ## Correlation Matrix ## ==================================== ## trade cgexp cgrev catho80 ## ------------------------------------ ## trade 1 0.179 0.346 -0.084 ## cgexp 0.179 1 0.909 -0.070 ## cgrev 0.346 0.909 1 -0.059 ## catho80 -0.084 -0.070 -0.059 1 ## ------------------------------------ 11.2 Basic regression analysis # Implements regression with &quot;gexp&quot; as DV, and assigns to object named &quot;regression1&quot; regression1&lt;-lm(cgexp~gastil+lyp+trade+prop1564+prop65+federal+oecd, data=pt_copy) # Prints regression table summary(regression1) ## ## Call: ## lm(formula = cgexp ~ gastil + lyp + trade + prop1564 + prop65 + ## federal + oecd, data = pt_copy) ## ## Residuals: ## Min 1Q Median 3Q Max ## -12.9861 -4.6981 -0.5521 4.4482 16.1124 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 52.17290 16.08572 3.243 0.00179 ** ## gastil -2.15202 1.10609 -1.946 0.05561 . ## lyp -2.04441 2.00721 -1.019 0.31184 ## trade 0.04978 0.01924 2.587 0.01170 * ## prop1564 -0.28482 0.26686 -1.067 0.28939 ## prop65 1.58627 0.33548 4.728 1.09e-05 *** ## federal -4.58101 2.38015 -1.925 0.05822 . ## oecd 0.96969 2.97171 0.326 0.74514 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 7.064 on 72 degrees of freedom ## (5 observations deleted due to missingness) ## Multiple R-squared: 0.5865, Adjusted R-squared: 0.5463 ## F-statistic: 14.59 on 7 and 72 DF, p-value: 1.137e-11 11.3 Working with categorical variables in a regression model 11.3.1 Working with categorical variables using factors # Set Continent variable as factor pt_copy$continent&lt;-as.factor(pt_copy$continent) # Examines levels of factor variable levels(pt_copy$continent) ## [1] &quot;africa&quot; &quot;asiae&quot; &quot;laam&quot; &quot;other&quot; # Relevels factor variable to set &quot;other&quot; as reference category pt_copy$continent&lt;-relevel(pt_copy$continent, ref=&quot;other&quot;) # Run regression with the continent variable and assign result to object named &quot;regression2&quot; regression2&lt;-lm(cgexp~gastil+lyp+trade+prop1564+prop65+federal+continent+col_espa+col_uka+col_otha+oecd, data=pt_copy) # Prints regression table for &quot;regression2&quot; summary(regression2) ## ## Call: ## lm(formula = cgexp ~ gastil + lyp + trade + prop1564 + prop65 + ## federal + continent + col_espa + col_uka + col_otha + oecd, ## data = pt_copy) ## ## Residuals: ## Min 1Q Median 3Q Max ## -14.3617 -3.9886 -0.3921 4.6050 17.3752 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 44.88833 17.56879 2.555 0.0129 * ## gastil -2.06438 1.13670 -1.816 0.0739 . ## lyp -0.12414 2.08305 -0.060 0.9527 ## trade 0.03018 0.02069 1.459 0.1494 ## prop1564 -0.25399 0.27421 -0.926 0.3577 ## prop65 0.98675 0.45822 2.153 0.0349 * ## federal -4.73466 2.34235 -2.021 0.0473 * ## continentafrica -3.42365 4.58573 -0.747 0.4580 ## continentasiae -7.72223 4.17322 -1.850 0.0687 . ## continentlaam -9.03522 4.25535 -2.123 0.0375 * ## col_espa 0.58034 8.05720 0.072 0.9428 ## col_uka 2.68929 3.22769 0.833 0.4077 ## col_otha -0.80223 3.02997 -0.265 0.7920 ## oecd -2.37769 3.33814 -0.712 0.4788 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.789 on 66 degrees of freedom ## (5 observations deleted due to missingness) ## Multiple R-squared: 0.6499, Adjusted R-squared: 0.5809 ## F-statistic: 9.424 on 13 and 66 DF, p-value: 1.21e-10 11.3.2 Working with categorical variables by creating dummy variables # Use &quot;continent&quot; field to make continent dummy variables pt_copy&lt;-pt_copy %&gt;% dummy_cols(&quot;continent&quot;) # run regression with continent dummies, with &quot;other&quot; category excluded regression2_alt&lt;-lm(cgexp~gastil+lyp+trade+prop1564+prop65+federal+continent_africa+ continent_asiae+continent_laam+col_espa+col_uka+col_otha+oecd, data=pt_copy) # Prints &quot;regression2_alt&quot; regression table summary(regression2_alt) ## ## Call: ## lm(formula = cgexp ~ gastil + lyp + trade + prop1564 + prop65 + ## federal + continent_africa + continent_asiae + continent_laam + ## col_espa + col_uka + col_otha + oecd, data = pt_copy) ## ## Residuals: ## Min 1Q Median 3Q Max ## -14.3617 -3.9886 -0.3921 4.6050 17.3752 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 44.88833 17.56879 2.555 0.0129 * ## gastil -2.06438 1.13670 -1.816 0.0739 . ## lyp -0.12414 2.08305 -0.060 0.9527 ## trade 0.03018 0.02069 1.459 0.1494 ## prop1564 -0.25399 0.27421 -0.926 0.3577 ## prop65 0.98675 0.45822 2.153 0.0349 * ## federal -4.73466 2.34235 -2.021 0.0473 * ## continent_africa -3.42365 4.58573 -0.747 0.4580 ## continent_asiae -7.72223 4.17322 -1.850 0.0687 . ## continent_laam -9.03522 4.25535 -2.123 0.0375 * ## col_espa 0.58034 8.05720 0.072 0.9428 ## col_uka 2.68929 3.22769 0.833 0.4077 ## col_otha -0.80223 3.02997 -0.265 0.7920 ## oecd -2.37769 3.33814 -0.712 0.4788 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.789 on 66 degrees of freedom ## (5 observations deleted due to missingness) ## Multiple R-squared: 0.6499, Adjusted R-squared: 0.5809 ## F-statistic: 9.424 on 13 and 66 DF, p-value: 1.21e-10 11.4 Working with interaction terms in regression models # run regression with interaction term between &quot;trade&quot; and &quot;federal&quot; trade_federal_interaction&lt;-lm(cgexp~trade*federal, data=pt_copy) # prints &quot;trade_federal_interaction&quot; regression table summary(trade_federal_interaction) ## ## Call: ## lm(formula = cgexp ~ trade * federal, data = pt_copy) ## ## Residuals: ## Min 1Q Median 3Q Max ## -20.0774 -8.1325 0.5782 7.7004 21.0072 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 26.708234 2.517787 10.608 &lt;2e-16 *** ## trade 0.034512 0.026410 1.307 0.195 ## federal -4.695595 5.512752 -0.852 0.397 ## trade:federal 0.009965 0.076991 0.129 0.897 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 10.42 on 77 degrees of freedom ## (4 observations deleted due to missingness) ## Multiple R-squared: 0.05761, Adjusted R-squared: 0.02089 ## F-statistic: 1.569 on 3 and 77 DF, p-value: 0.2037 11.4.1 Plotting marginal effects # Finds mean value of trade variable mean(pt_copy$trade) ## [1] 78.7659 # Calculates marginal effects of federalism, with &quot;trade&quot; held at mean marginal_effect_federalism&lt;-ggpredict(trade_federal_interaction, terms=&quot;federal&quot;, condition=c(trade=78.7659)) # Prints marginal effects table marginal_effect_federalism ## # Predicted values of cgexp ## ## federal | Predicted | 95% CI ## ---------------------------------- ## 0 | 29.43 | 26.90, 31.95 ## 1 | 25.52 | 18.81, 32.22 # Plot marginal effects of federalism ggpredict(trade_federal_interaction, terms=&quot;federal&quot;) %&gt;% ggplot(aes(x, predicted))+ geom_point()+ geom_errorbar(aes(ymin=conf.low, ymax=conf.high),width=0.05)+ scale_x_continuous(breaks=(seq(0,1, by=1)))+ labs(title=&quot;Predicted Effects of Federalism on Gov&#39;t Expenditure\\n(with trade set to mean)&quot;, y=&quot;Predicted Expenditure&quot;, x=&quot;Federalism&quot;) 11.5 Creating and exporting regression tables # Put the regression models you want in your regression table in a list model_list&lt;-list(regression1,regression2) # Exporting table as text file stargazer(model_list, type=&quot;text&quot;, out=&quot;cgexp_regressions.txt&quot;) # Exporting regression table as html file stargazer(model_list, type=&quot;html&quot;, out=&quot;cgexp_regressions.html&quot;) "],["working-with-multiple-datasets.html", "12 Working with multiple datasets 12.1 Reading in multiple files 12.2 Merging Data 12.3 Appending Data 12.4 Reshaping Data 12.5 Automating data processing tasks", " 12 Working with multiple datasets 12.1 Reading in multiple files # extracts file names in working directory worldbank_filenames&lt;-list.files() # prints file names in working directory worldbank_filenames ## [1] &quot;wdi_debt2019.csv&quot; &quot;wdi_fdi2019.csv&quot; &quot;wdi_trade2019.csv&quot; &quot;wdi_urban2019.csv&quot; setwd(&quot;data/wb&quot;) # iteratively reads in World Bank files from working directory and assigns them to a new list object named &quot;world_bank_list&quot; world_bank_list&lt;-map(worldbank_filenames, read_csv) ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 271 Columns: 5 ## ── Column specification ────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Country Name, Country Code, Series Name, Series Code, 2019 [YR2019] ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # prints datasets in &quot;world_bank_list&quot; world_bank_list ## [[1]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Central government debt, total (% of … GC.DOD.TOTL.… .. ## 2 Albania ALB Central government debt, total (% of … GC.DOD.TOTL.… 75.69848824949… ## 3 Algeria DZA Central government debt, total (% of … GC.DOD.TOTL.… .. ## 4 American Samoa ASM Central government debt, total (% of … GC.DOD.TOTL.… .. ## 5 Andorra AND Central government debt, total (% of … GC.DOD.TOTL.… .. ## 6 Angola AGO Central government debt, total (% of … GC.DOD.TOTL.… .. ## 7 Antigua and Barbuda ATG Central government debt, total (% of … GC.DOD.TOTL.… .. ## 8 Argentina ARG Central government debt, total (% of … GC.DOD.TOTL.… .. ## 9 Armenia ARM Central government debt, total (% of … GC.DOD.TOTL.… 50.02842068637… ## 10 Aruba ABW Central government debt, total (% of … GC.DOD.TOTL.… .. ## # ℹ 261 more rows ## ## [[2]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Foreign direct investment, net inflow… BX.KLT.DINV.… 0.124495985791… ## 2 Albania ALB Foreign direct investment, net inflow… BX.KLT.DINV.… 7.797920483865… ## 3 Algeria DZA Foreign direct investment, net inflow… BX.KLT.DINV.… 0.804144058246… ## 4 American Samoa ASM Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 5 Andorra AND Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 6 Angola AGO Foreign direct investment, net inflow… BX.KLT.DINV.… -5.78081314444… ## 7 Antigua and Barbuda ATG Foreign direct investment, net inflow… BX.KLT.DINV.… 7.433324076307… ## 8 Argentina ARG Foreign direct investment, net inflow… BX.KLT.DINV.… 1.485006875706… ## 9 Armenia ARM Foreign direct investment, net inflow… BX.KLT.DINV.… 0.736361516844… ## 10 Aruba ABW Foreign direct investment, net inflow… BX.KLT.DINV.… -2.21528256776… ## # ℹ 261 more rows ## ## [[3]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Trade (% of GDP) NE.TRD.GNFS.ZS .. ## 2 Albania ALB Trade (% of GDP) NE.TRD.GNFS.ZS 76.2791946495763 ## 3 Algeria DZA Trade (% of GDP) NE.TRD.GNFS.ZS 51.8097384415762 ## 4 American Samoa ASM Trade (% of GDP) NE.TRD.GNFS.ZS 156.568778979907 ## 5 Andorra AND Trade (% of GDP) NE.TRD.GNFS.ZS .. ## 6 Angola AGO Trade (% of GDP) NE.TRD.GNFS.ZS 57.8295381183036 ## 7 Antigua and Barbuda ATG Trade (% of GDP) NE.TRD.GNFS.ZS 137.625175755884 ## 8 Argentina ARG Trade (% of GDP) NE.TRD.GNFS.ZS 32.6306150458499 ## 9 Armenia ARM Trade (% of GDP) NE.TRD.GNFS.ZS 96.1141541288708 ## 10 Aruba ABW Trade (% of GDP) NE.TRD.GNFS.ZS 145.343572735289 ## # ℹ 261 more rows ## ## [[4]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Urban population (% of total populati… SP.URB.TOTL.… 25.754 ## 2 Albania ALB Urban population (% of total populati… SP.URB.TOTL.… 61.229 ## 3 Algeria DZA Urban population (% of total populati… SP.URB.TOTL.… 73.189 ## 4 American Samoa ASM Urban population (% of total populati… SP.URB.TOTL.… 87.147 ## 5 Andorra AND Urban population (% of total populati… SP.URB.TOTL.… 87.984 ## 6 Angola AGO Urban population (% of total populati… SP.URB.TOTL.… 66.177 ## 7 Antigua and Barbuda ATG Urban population (% of total populati… SP.URB.TOTL.… 24.506 ## 8 Argentina ARG Urban population (% of total populati… SP.URB.TOTL.… 91.991 ## 9 Armenia ARM Urban population (% of total populati… SP.URB.TOTL.… 63.219 ## 10 Aruba ABW Urban population (% of total populati… SP.URB.TOTL.… 43.546 ## # ℹ 261 more rows # removes CSV extension from &quot;worldbank_filenames&quot; worldbank_filenames_base&lt;-str_remove(worldbank_filenames, &quot;.csv&quot;) # assigns names to datasets in &quot;world_bank_list&quot; names(world_bank_list)&lt;-worldbank_filenames_base # extracts fdi dataset from &quot;world_bank_list&quot; by assigned name world_bank_list[[&quot;wdi_fdi2019&quot;]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Foreign direct investment, net inflow… BX.KLT.DINV.… 0.124495985791… ## 2 Albania ALB Foreign direct investment, net inflow… BX.KLT.DINV.… 7.797920483865… ## 3 Algeria DZA Foreign direct investment, net inflow… BX.KLT.DINV.… 0.804144058246… ## 4 American Samoa ASM Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 5 Andorra AND Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 6 Angola AGO Foreign direct investment, net inflow… BX.KLT.DINV.… -5.78081314444… ## 7 Antigua and Barbuda ATG Foreign direct investment, net inflow… BX.KLT.DINV.… 7.433324076307… ## 8 Argentina ARG Foreign direct investment, net inflow… BX.KLT.DINV.… 1.485006875706… ## 9 Armenia ARM Foreign direct investment, net inflow… BX.KLT.DINV.… 0.736361516844… ## 10 Aruba ABW Foreign direct investment, net inflow… BX.KLT.DINV.… -2.21528256776… ## # ℹ 261 more rows # extracts fdi dataset from &quot;world_bank_list&quot; by index world_bank_list[[2]] ## # A tibble: 271 × 5 ## `Country Name` `Country Code` `Series Name` `Series Code` `2019 [YR2019]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG Foreign direct investment, net inflow… BX.KLT.DINV.… 0.124495985791… ## 2 Albania ALB Foreign direct investment, net inflow… BX.KLT.DINV.… 7.797920483865… ## 3 Algeria DZA Foreign direct investment, net inflow… BX.KLT.DINV.… 0.804144058246… ## 4 American Samoa ASM Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 5 Andorra AND Foreign direct investment, net inflow… BX.KLT.DINV.… .. ## 6 Angola AGO Foreign direct investment, net inflow… BX.KLT.DINV.… -5.78081314444… ## 7 Antigua and Barbuda ATG Foreign direct investment, net inflow… BX.KLT.DINV.… 7.433324076307… ## 8 Argentina ARG Foreign direct investment, net inflow… BX.KLT.DINV.… 1.485006875706… ## 9 Armenia ARM Foreign direct investment, net inflow… BX.KLT.DINV.… 0.736361516844… ## 10 Aruba ABW Foreign direct investment, net inflow… BX.KLT.DINV.… -2.21528256776… ## # ℹ 261 more rows 12.2 Merging Data # extracts World Bank FDI dataset and assigns it to a new object named WB_fdi WB_fdi&lt;-world_bank_list[[2]] # extracts World Bank debt dataset and assigns it to a new object named WB_debt WB_debt&lt;-world_bank_list[[1]] 12.3 Appending Data 12.4 Reshaping Data 12.5 Automating data processing tasks # write function to World Bank dataset worldbank_cleaning_function&lt;-function(input_dataset){ modified_dataset&lt;-input_dataset %&gt;% select(-&quot;Series Code&quot;) %&gt;% rename(&quot;Country&quot;=&quot;Country Name&quot;, &quot;CountryCode&quot;=&quot;Country Code&quot;, &quot;Series&quot;=&quot;Series Name&quot;, &quot;2019&quot;=&quot;2019 [YR2019]&quot;) %&gt;% drop_na(CountryCode) return(modified_dataset) } # Iteratively apply &quot;worldbank_cleaning_function&quot; to all of the datasets in &quot;world_bank_list&quot;, and deposit the cleaned datasets into a new list named &quot;world_bank_list_cleaned&quot; world_bank_list_cleaned&lt;-map(world_bank_list, worldbank_cleaning_function) "],["data-transfer-part-2-exporting-data.html", "13 Data Transfer Part 2: Exporting data 13.1 Exporting a data frame 13.2 Exporting multiple data frames 13.3 Exporting other objects (i.e. visualizations)", " 13 Data Transfer Part 2: Exporting data 13.1 Exporting a data frame 13.2 Exporting multiple data frames # create file names for exported World Bank files WB_filenames_export&lt;-paste0(worldbank_filenames_base, &quot;_cleaned.csv&quot;) # exports datasets in &quot;world_bank_list_cleaned&quot; to working directory using filenames in &quot;WB_filenames_export&quot; walk2(world_bank_list_cleaned, WB_filenames_export, write_csv) 13.3 Exporting other objects (i.e. visualizations) "],["practice-exercises.html", "14 Practice Exercises", " 14 Practice Exercises "],["replication-exercise.html", "15 Replication Exercise", " 15 Replication Exercise "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
